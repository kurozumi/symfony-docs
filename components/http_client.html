

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ja" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ja" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The HttpClient Component &mdash; Symfony Framework Documentation  ドキュメント</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="next" title="The HttpFoundation Component" href="http_foundation.html" />
    <link rel="prev" title="How to Choose Validation Groups Based on the Submitted Data" href="../form/data_based_validation.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Symfony Framework Documentation
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../quick_tour/index.html">The Quick Tour</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/index.html">Getting Started</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../best_practices.html">The Symfony Framework Best Practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bundles.html">The Bundle System</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cache.html">Cache</a></li>
<li class="toctree-l1"><a class="reference internal" href="../console.html">Console Commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doctrine.html">Databases and the Doctrine ORM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment.html">How to Deploy a Symfony Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="../email.html">Swift Mailer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../event_dispatcher.html">Events and Event Listeners</a></li>
<li class="toctree-l1"><a class="reference internal" href="../forms.html">Forms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../frontend.html">Managing CSS and JavaScript</a></li>
<li class="toctree-l1"><a class="reference internal" href="../http_cache.html">HTTP Cache</a></li>
<li class="toctree-l1"><a class="reference internal" href="../logging.html">Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mailer.html">Sending Emails with Mailer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mercure.html">Pushing Data to Clients Using the Mercure Protocol</a></li>
<li class="toctree-l1"><a class="reference internal" href="../messenger.html">Messenger: Sync &amp; Queued Message Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../migration.html">Migrating an Existing Application to Symfony</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notifier.html">Creating and Sending Notifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance.html">Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiler.html">Profiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../routing.html">Routing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security.html">Security</a></li>
<li class="toctree-l1"><a class="reference internal" href="../session.html">Sessions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../setup.html">Installing &amp; Setting up the Symfony Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../serializer.html">How to Use the Serializer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../service_container.html">Service Container</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../translation.html">Translations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../validation.html">Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../web_link.html">Asset Preloading and Resource Hints with HTTP/2 and WebLink</a></li>
<li class="toctree-l1"><a class="reference internal" href="../workflow.html">Workflow</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Components</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="using_components.html">How to Install and Use the Symfony Components</a></li>
<li class="toctree-l2"><a class="reference internal" href="asset.html">The Asset Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="browser_kit.html">The BrowserKit Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="cache.html">The Cache Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="class_loader.html">The ClassLoader Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="config.html">The Config Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">The Console Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="contracts.html">The Contracts Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="css_selector.html">The CssSelector Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="dependency_injection.html">The DependencyInjection Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="dom_crawler.html">The DomCrawler Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="dotenv.html">The Dotenv Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="error_handler.html">The ErrorHandler Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_dispatcher.html">The EventDispatcher Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="expression_language.html">The ExpressionLanguage Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="filesystem.html">The Filesystem Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="finder.html">The Finder Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="form.html">The Form Component</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">The HttpClient Component</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#installation">Installation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basic-usage">Basic Usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performance">Performance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#enabling-curl-support">Enabling cURL Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#http-2-support">HTTP/2 Support</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#making-requests">Making Requests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#authentication">Authentication</a></li>
<li class="toctree-l4"><a class="reference internal" href="#query-string-parameters">Query String Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#headers">Headers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#uploading-data">Uploading Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cookies">Cookies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#redirects">Redirects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#http-proxies">HTTP Proxies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#progress-callback">Progress Callback</a></li>
<li class="toctree-l4"><a class="reference internal" href="#advanced-options">Advanced Options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#processing-responses">Processing Responses</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#streaming-responses">Streaming Responses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#canceling-responses">Canceling Responses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#handling-exceptions">Handling Exceptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#concurrent-requests">Concurrent Requests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#multiplexing-responses">Multiplexing Responses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dealing-with-network-timeouts">Dealing with Network Timeouts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dealing-with-network-errors">Dealing with Network Errors</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#caching-requests-and-responses">Caching Requests and Responses</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scoping-client">Scoping Client</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interoperability">Interoperability</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#symfony-contracts">Symfony Contracts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#psr-18-and-psr-17">PSR-18 and PSR-17</a></li>
<li class="toctree-l4"><a class="reference internal" href="#httplug">HTTPlug</a></li>
<li class="toctree-l4"><a class="reference internal" href="#native-php-streams">Native PHP Streams</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#symfony-framework-integration">Symfony Framework Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#configuration">Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#injecting-the-http-client-into-services">Injecting the HTTP Client into Services</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#testing-http-clients-and-responses">Testing HTTP Clients and Responses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="http_foundation.html">The HttpFoundation Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="http_kernel.html">The HttpKernel Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="inflector.html">The Inflector Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="intl.html">The Intl Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="ldap.html">The Ldap Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="lock.html">The Lock Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="mailer.html">The Mailer Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="mercure.html">The Mercure Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="messenger.html">The Messenger Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="mime.html">The Mime Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="options_resolver.html">The OptionsResolver Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="phpunit_bridge.html">The PHPUnit Bridge</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_apcu.html">The Symfony Polyfill / APCu Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_ctype.html">The Symfony Polyfill / Ctype Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_iconv.html">The Symfony Polyfill / Iconv Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_intl_grapheme.html">The Symfony Polyfill / Intl Grapheme Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_intl_icu.html">The Symfony Polyfill / Intl ICU Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_intl_idn.html">The Symfony Polyfill / Intl IDN Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_intl_messageformatter.html">The Symfony Polyfill / Intl MessageFormatter Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_intl_normalizer.html">The Symfony Polyfill / Intl Normalizer Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_mbstring.html">The Symfony Polyfill / Mbstring Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_php54.html">The Symfony Polyfill / PHP 5.4 Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_php55.html">The Symfony Polyfill / PHP 5.5 Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_php56.html">The Symfony Polyfill / PHP 5.6 Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_php70.html">The Symfony Polyfill / PHP 7.0 Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_php71.html">The Symfony Polyfill / PHP 7.1 Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_php72.html">The Symfony Polyfill / PHP 7.2 Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_php73.html">The Symfony Polyfill / PHP 7.3 Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="polyfill_uuid.html">The Symfony Polyfill / UUID Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="process.html">The Process Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="property_access.html">The PropertyAccess Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="property_info.html">The PropertyInfo Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="psr7.html">The PSR-7 Bridge</a></li>
<li class="toctree-l2"><a class="reference internal" href="security.html">The Security Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="serializer.html">The Serializer Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="stopwatch.html">The Stopwatch Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="string.html">The String Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="templating.html">The Templating Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="uid.html">The UID Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="validator.html">The Validator Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="var_dumper.html">The VarDumper Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="var_exporter.html">The VarExporter Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="web_link.html">The WebLink Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="workflow.html">The Workflow Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="yaml.html">The Yaml Component</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Reference Documents</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributing</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../create_framework/index.html">Create your own PHP Framework</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Symfony Framework Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Components</a> &raquo;</li>
        
      <li>The HttpClient Component</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/components/http_client.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-httpclient-component">
<span id="index-0"></span><h1>The HttpClient Component<a class="headerlink" href="#the-httpclient-component" title="このヘッドラインへのパーマリンク">¶</a></h1>
<blockquote>
<div>The HttpClient component is a low-level HTTP client with support for both
PHP stream wrappers and cURL. It provides utilities to consume APIs and
supports synchronous and asynchronous operations.</div></blockquote>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-terminal"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">$</span> composer require symfony/http-client
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">If you install this component outside of a Symfony application, you must
require the <code class="docutils literal"><span class="pre">vendor/autoload.php</span></code> file in your code to enable the class
autoloading mechanism provided by Composer. Read
<a class="reference internal" href="using_components.html"><em>this article</em></a> for more details.</p>
</div>
</div>
<div class="section" id="basic-usage">
<h2>Basic Usage<a class="headerlink" href="#basic-usage" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Use the <code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpClient/HttpClient.html" title="Symfony\Component\HttpClient\HttpClient"><span class="pre">HttpClient</span></a></code> class to create the
low-level HTTP client that makes requests, like the following <code class="docutils literal"><span class="pre">GET</span></code> request:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\HttpClient</span><span class="p">;</span>

<span class="nv">$client</span> <span class="o">=</span> <span class="nx">HttpClient</span><span class="o">::</span><span class="na">create</span><span class="p">();</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;https://api.github.com/repos/symfony/symfony-docs&#39;</span><span class="p">);</span>

<span class="nv">$statusCode</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getStatusCode</span><span class="p">();</span>
<span class="c1">// $statusCode = 200</span>
<span class="nv">$contentType</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getHeaders</span><span class="p">()[</span><span class="s1">&#39;content-type&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
<span class="c1">// $contentType = &#39;application/json&#39;</span>
<span class="nv">$content</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getContent</span><span class="p">();</span>
<span class="c1">// $content = &#39;{&quot;id&quot;:521583, &quot;name&quot;:&quot;symfony-docs&quot;, ...}&#39;</span>
<span class="nv">$content</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">toArray</span><span class="p">();</span>
<span class="c1">// $content = [&#39;id&#39; =&gt; 521583, &#39;name&#39; =&gt; &#39;symfony-docs&#39;, ...]</span>
</pre></div>
</div>
</div>
<div class="section" id="performance">
<h2>Performance<a class="headerlink" href="#performance" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The component is built for maximum HTTP performance. By design, it is compatible
with HTTP/2 and with doing concurrent asynchronous streamed and multiplexed
requests/responses. Even when doing regular synchronous calls, this design
allows keeping connections to remote hosts open between requests, improving
performance by saving repetitive DNS resolution, SSL negotiation, etc.</p>
<div class="section" id="enabling-curl-support">
<h3>Enabling cURL Support<a class="headerlink" href="#enabling-curl-support" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>This component supports both the native PHP streams and cURL to make the HTTP
requests. Both are interchangeable and provide the same features, including
concurrent requests and HTTP/2 support.</p>
<p><code class="docutils literal"><span class="pre">HttpClient::create()</span></code> selects the cURL transport if the <a class="reference external" href="https://www.php.net/curl">cURL PHP extension</a>
is enabled and falls back to PHP streams otherwise. If you prefer to select
the transport explicitly, use the following classes to create the client:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\CurlHttpClient</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\NativeHttpClient</span><span class="p">;</span>

<span class="c1">// uses native PHP streams</span>
<span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">NativeHttpClient</span><span class="p">();</span>

<span class="c1">// uses the cURL PHP extension</span>
<span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CurlHttpClient</span><span class="p">();</span>
</pre></div>
</div>
<p>When using this component in a full-stack Symfony application, this behavior is
not configurable and cURL will be used automatically if the cURL PHP extension
is installed and enabled. Otherwise, the native PHP streams will be used.</p>
</div>
<div class="section" id="http-2-support">
<h3>HTTP/2 Support<a class="headerlink" href="#http-2-support" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">バージョン 5.1 で追加: </span>Integration with <code class="docutils literal"><span class="pre">amphp/http-client</span></code> was introduced in Symfony 5.1.
Prior to this version, HTTP/2 was only supported when <code class="docutils literal"><span class="pre">libcurl</span></code> was
installed.</p>
</div>
<p>The component supports HTTP/2 if one of the following tools is
installed:</p>
<ul class="simple">
<li>The <a class="reference external" href="https://curl.haxx.se/libcurl/">libcurl</a> package version 7.36 or higher;</li>
<li>The <a class="reference external" href="https://packagist.org/packages/amphp/http-client">amphp/http-client</a> Packagist package version 4.2 or higher.</li>
</ul>
<p>When requesting an <code class="docutils literal"><span class="pre">https</span></code> URL and HTTP/2 is supported by your server,
HTTP/2 is enabled by default. To force HTTP/2 for <code class="docutils literal"><span class="pre">http</span></code> URLs, you need
to enable it explicitly via the <code class="docutils literal"><span class="pre">http_version</span></code> option:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="nv">$client</span> <span class="o">=</span> <span class="nx">HttpClient</span><span class="o">::</span><span class="na">create</span><span class="p">([</span><span class="s1">&#39;http_version&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2.0&#39;</span><span class="p">]);</span>
</pre></div>
</div>
<p>Support for HTTP/2 PUSH works out of the box when libcurl &gt;= 7.61 is used with
PHP &gt;= 7.2.17 / 7.3.4: pushed responses are put into a temporary cache and are
used when a subsequent request is triggered for the corresponding URLs.</p>
</div>
</div>
<div class="section" id="making-requests">
<h2>Making Requests<a class="headerlink" href="#making-requests" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The client created with the <code class="docutils literal"><span class="pre">HttpClient</span></code> class provides a single <code class="docutils literal"><span class="pre">request()</span></code>
method to perform all kinds of HTTP requests:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;https://...&#39;</span><span class="p">);</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;https://...&#39;</span><span class="p">);</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;PUT&#39;</span><span class="p">,</span> <span class="s1">&#39;https://...&#39;</span><span class="p">);</span>
<span class="c1">// ...</span>
</pre></div>
</div>
<p>Responses are always asynchronous, so that the call to the method returns
immediately instead of waiting to receive the response:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="c1">// code execution continues immediately; it doesn&#39;t wait to receive the response</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;http://releases.ubuntu.com/18.04.2/ubuntu-18.04.2-desktop-amd64.iso&#39;</span><span class="p">);</span>

<span class="c1">// getting the response headers waits until they arrive</span>
<span class="nv">$contentType</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getHeaders</span><span class="p">()[</span><span class="s1">&#39;content-type&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>

<span class="c1">// trying to get the response contents will block the execution until</span>
<span class="c1">// the full response contents are received</span>
<span class="nv">$contents</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getContent</span><span class="p">();</span>
</pre></div>
</div>
<p>This component also supports <a class="reference internal" href="#http-client-streaming-responses"><span>streaming responses</span></a>
for full asynchronous applications.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">HTTP compression and chunked transfer encoding are automatically enabled when
both your PHP runtime and the remote server support them.</p>
</div>
<div class="section" id="authentication">
<h3>Authentication<a class="headerlink" href="#authentication" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The HTTP client supports different authentication mechanisms. They can be
defined globally when creating the client (to apply it to all requests) and to
each request (which overrides any global authentication):</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="c1">// Use the same authentication for all requests to https://example.com/</span>
<span class="nv">$client</span> <span class="o">=</span> <span class="nx">HttpClient</span><span class="o">::</span><span class="na">createForBaseUri</span><span class="p">(</span><span class="s1">&#39;https://example.com/&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="c1">// HTTP Basic authentication (there are multiple ways of configuring it)</span>
    <span class="s1">&#39;auth_basic&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;the-username&#39;</span><span class="p">],</span>
    <span class="s1">&#39;auth_basic&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;the-username&#39;</span><span class="p">,</span> <span class="s1">&#39;the-password&#39;</span><span class="p">],</span>
    <span class="s1">&#39;auth_basic&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;the-username:the-password&#39;</span><span class="p">,</span>

    <span class="c1">// HTTP Bearer authentication (also called token authentication)</span>
    <span class="s1">&#39;auth_bearer&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;the-bearer-token&#39;</span><span class="p">,</span>

    <span class="c1">// Microsoft NTLM authentication (there are multiple ways of configuring it)</span>
    <span class="s1">&#39;auth_ntlm&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;the-username&#39;</span><span class="p">],</span>
    <span class="s1">&#39;auth_ntlm&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;the-username&#39;</span><span class="p">,</span> <span class="s1">&#39;the-password&#39;</span><span class="p">],</span>
    <span class="s1">&#39;auth_ntlm&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;the-username:the-password&#39;</span><span class="p">,</span>
<span class="p">]);</span>

<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;https://...&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="c1">// use a different HTTP Basic authentication only for this request</span>
    <span class="s1">&#39;auth_basic&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;the-username&#39;</span><span class="p">,</span> <span class="s1">&#39;the-password&#39;</span><span class="p">],</span>

    <span class="c1">// ...</span>
<span class="p">]);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">The NTLM authentication mechanism requires using the cURL transport.
By using <code class="docutils literal"><span class="pre">HttpClient::createForBaseUri()</span></code>, we ensure that the auth credentials
won&#8217;t be sent to any other hosts than <a class="reference external" href="https://example.com/">https://example.com/</a>.</p>
</div>
</div>
<div class="section" id="query-string-parameters">
<h3>Query String Parameters<a class="headerlink" href="#query-string-parameters" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>You can either append them manually to the requested URL, or define them as an
associative array via the <code class="docutils literal"><span class="pre">query</span></code> option, that will be merged with the URL:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="c1">// it makes an HTTP GET request to https://httpbin.org/get?token=...&amp;name=...</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;https://httpbin.org/get&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="c1">// these values are automatically encoded before including them in the URL</span>
    <span class="s1">&#39;query&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;token&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;...&#39;</span><span class="p">,</span>
        <span class="s1">&#39;name&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;...&#39;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">]);</span>
</pre></div>
</div>
</div>
<div class="section" id="headers">
<h3>Headers<a class="headerlink" href="#headers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Use the <code class="docutils literal"><span class="pre">headers</span></code> option to define both the default headers added to all
requests and the specific headers for each request:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="c1">// this header is added to all requests made by this client</span>
<span class="nv">$client</span> <span class="o">=</span> <span class="nx">HttpClient</span><span class="o">::</span><span class="na">create</span><span class="p">([</span><span class="s1">&#39;headers&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
    <span class="s1">&#39;User-Agent&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;My Fancy App&#39;</span><span class="p">,</span>
<span class="p">]]);</span>

<span class="c1">// this header is only included in this request and overrides the value</span>
<span class="c1">// of the same header if defined globally by the HTTP client</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;https://...&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;headers&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;Content-Type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">]);</span>
</pre></div>
</div>
</div>
<div class="section" id="uploading-data">
<h3>Uploading Data<a class="headerlink" href="#uploading-data" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>This component provides several methods for uploading data using the <code class="docutils literal"><span class="pre">body</span></code>
option. You can use regular strings, closures, iterables and resources and they&#8217;ll be
processed automatically when making the requests:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;https://...&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="c1">// defining data using a regular string</span>
    <span class="s1">&#39;body&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;raw data&#39;</span><span class="p">,</span>

    <span class="c1">// defining data using an array of parameters</span>
    <span class="s1">&#39;body&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;parameter1&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;value1&#39;</span><span class="p">,</span> <span class="s1">&#39;...&#39;</span><span class="p">],</span>

    <span class="c1">// using a closure to generate the uploaded data</span>
    <span class="s1">&#39;body&#39;</span> <span class="o">=&gt;</span> <span class="k">function</span> <span class="p">(</span><span class="nx">int</span> <span class="nv">$size</span><span class="p">)</span><span class="o">:</span> <span class="nx">string</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">},</span>

    <span class="c1">// using a resource to get the data from it</span>
    <span class="s1">&#39;body&#39;</span> <span class="o">=&gt;</span> <span class="nb">fopen</span><span class="p">(</span><span class="s1">&#39;/path/to/file&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">),</span>
<span class="p">]);</span>
</pre></div>
</div>
<p>When uploading data with the <code class="docutils literal"><span class="pre">POST</span></code> method, if you don&#8217;t define the
<code class="docutils literal"><span class="pre">Content-Type</span></code> HTTP header explicitly, Symfony assumes that you&#8217;re uploading
form data and adds the required
<code class="docutils literal"><span class="pre">'Content-Type:</span> <span class="pre">application/x-www-form-urlencoded'</span></code> header for you.</p>
<p>When the <code class="docutils literal"><span class="pre">body</span></code> option is set as a closure, it will be called several times until
it returns the empty string, which signals the end of the body. Each time, the
closure should return a string smaller than the amount requested as argument.</p>
<p>A generator or any <code class="docutils literal"><span class="pre">Traversable</span></code> can also be used instead of a closure.</p>
<div class="admonition tip">
<p class="first admonition-title">ちなみに</p>
<p>When uploading JSON payloads, use the <code class="docutils literal"><span class="pre">json</span></code> option instead of <code class="docutils literal"><span class="pre">body</span></code>. The
given content will be JSON-encoded automatically and the request will add the
<code class="docutils literal"><span class="pre">Content-Type:</span> <span class="pre">application/json</span></code> automatically too:</p>
<div class="last highlight-php"><div class="highlight"><pre><span></span><span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;https://...&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;json&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;param1&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;value1&#39;</span><span class="p">,</span> <span class="s1">&#39;...&#39;</span><span class="p">],</span>
<span class="p">]);</span>

<span class="nv">$decodedPayload</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">toArray</span><span class="p">();</span>
</pre></div>
</div>
</div>
<p>To submit a form with file uploads, it is your responsibility to encode the body
according to the <code class="docutils literal"><span class="pre">multipart/form-data</span></code> content-type. The
<a class="reference internal" href="mime.html"><em>Symfony Mime</em></a> component makes it a few lines of code:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Mime\Part\DataPart</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Mime\Part\Multipart\FormDataPart</span><span class="p">;</span>

<span class="nv">$formFields</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;regular_field&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;some value&#39;</span><span class="p">,</span>
    <span class="s1">&#39;file_field&#39;</span> <span class="o">=&gt;</span> <span class="nx">DataPart</span><span class="o">::</span><span class="na">fromPath</span><span class="p">(</span><span class="s1">&#39;/path/to/uploaded/file&#39;</span><span class="p">),</span>
<span class="p">];</span>
<span class="nv">$formData</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FormDataPart</span><span class="p">(</span><span class="nv">$formFields</span><span class="p">);</span>
<span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;https://...&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;headers&#39;</span> <span class="o">=&gt;</span> <span class="nv">$formData</span><span class="o">-&gt;</span><span class="na">getPreparedHeaders</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">toArray</span><span class="p">(),</span>
    <span class="s1">&#39;body&#39;</span> <span class="o">=&gt;</span> <span class="nv">$formData</span><span class="o">-&gt;</span><span class="na">bodyToIterable</span><span class="p">(),</span>
<span class="p">]);</span>
</pre></div>
</div>
</div>
<div class="section" id="cookies">
<h3>Cookies<a class="headerlink" href="#cookies" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The HTTP client provided by this component is stateless but handling cookies
requires a stateful storage (because responses can update cookies and they must
be used for subsequent requests). That&#8217;s why this component doesn&#8217;t handle
cookies automatically.</p>
<p>You can either handle cookies yourself using the <code class="docutils literal"><span class="pre">Cookie</span></code> HTTP header or use
the <a class="reference internal" href="browser_kit.html"><em>BrowserKit component</em></a> which provides this
feature and integrates seamlessly with the HttpClient component.</p>
</div>
<div class="section" id="redirects">
<h3>Redirects<a class="headerlink" href="#redirects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>By default, the HTTP client follows redirects, up to a maximum of 20, when
making a request. Use the <code class="docutils literal"><span class="pre">max_redirects</span></code> setting to configure this behavior
(if the number of redirects is higher than the configured value, you&#8217;ll get a
<code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpClient/Exception/RedirectionException.html" title="Symfony\Component\HttpClient\Exception\RedirectionException"><span class="pre">RedirectionException</span></a></code>):</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;https://...&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="c1">// 0 means to not follow any redirect</span>
    <span class="s1">&#39;max_redirects&#39;</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">]);</span>
</pre></div>
</div>
</div>
<div class="section" id="http-proxies">
<h3>HTTP Proxies<a class="headerlink" href="#http-proxies" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>By default, this component honors the standard environment variables that your
Operating System defines to direct the HTTP traffic through your local proxy.
This means there is usually nothing to configure to have the client work with
proxies, provided these env vars are properly configured.</p>
<p>You can still set or override these settings using the <code class="docutils literal"><span class="pre">proxy</span></code> and <code class="docutils literal"><span class="pre">no_proxy</span></code>
options:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">proxy</span></code> should be set to the <code class="docutils literal"><span class="pre">http://...</span></code> URL of the proxy to get through</li>
<li><code class="docutils literal"><span class="pre">no_proxy</span></code> disables the proxy for a comma-separated list of hosts that do not
require it to get reached.</li>
</ul>
</div>
<div class="section" id="progress-callback">
<h3>Progress Callback<a class="headerlink" href="#progress-callback" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>By providing a callable to the <code class="docutils literal"><span class="pre">on_progress</span></code> option, one can track
uploads/downloads as they complete. This callback is guaranteed to be called on
DNS resolution, on arrival of headers and on completion; additionally it is
called when new data is uploaded or downloaded and at least once per second:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;https://...&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;on_progress&#39;</span> <span class="o">=&gt;</span> <span class="k">function</span> <span class="p">(</span><span class="nx">int</span> <span class="nv">$dlNow</span><span class="p">,</span> <span class="nx">int</span> <span class="nv">$dlSize</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$info</span><span class="p">)</span><span class="o">:</span> <span class="nx">void</span> <span class="p">{</span>
        <span class="c1">// $dlNow is the number of bytes downloaded so far</span>
        <span class="c1">// $dlSize is the total size to be downloaded or -1 if it is unknown</span>
        <span class="c1">// $info is what $response-&gt;getInfo() would return at this very time</span>
    <span class="p">},</span>
<span class="p">]);</span>
</pre></div>
</div>
<p>Any exceptions thrown from the callback will be wrapped in an instance of
<code class="docutils literal"><span class="pre">TransportExceptionInterface</span></code> and will abort the request.</p>
</div>
<div class="section" id="advanced-options">
<h3>Advanced Options<a class="headerlink" href="#advanced-options" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The <code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Contracts/HttpClient/HttpClientInterface.html" title="Symfony\Contracts\HttpClient\HttpClientInterface"><span class="pre">HttpClientInterface</span></a></code> defines all the
options you might need to take full control of the way the request is performed,
including DNS pre-resolution, SSL parameters, public key pinning, etc.</p>
</div>
</div>
<div class="section" id="processing-responses">
<h2>Processing Responses<a class="headerlink" href="#processing-responses" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The response returned by all HTTP clients is an object of type
<code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Contracts/HttpClient/ResponseInterface.html" title="Symfony\Contracts\HttpClient\ResponseInterface"><span class="pre">ResponseInterface</span></a></code> which provides the
following methods:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;https://...&#39;</span><span class="p">);</span>

<span class="c1">// gets the HTTP status code of the response</span>
<span class="nv">$statusCode</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getStatusCode</span><span class="p">();</span>

<span class="c1">// gets the HTTP headers as string[][] with the header names lower-cased</span>
<span class="nv">$headers</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getHeaders</span><span class="p">();</span>

<span class="c1">// gets the response body as a string</span>
<span class="nv">$content</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getContent</span><span class="p">();</span>

<span class="c1">// casts the response JSON contents to a PHP array</span>
<span class="nv">$content</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">toArray</span><span class="p">();</span>

<span class="c1">// casts the response content to a PHP stream resource</span>
<span class="nv">$content</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">toStream</span><span class="p">();</span>

<span class="c1">// cancels the request/response</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">cancel</span><span class="p">();</span>

<span class="c1">// returns info coming from the transport layer, such as &quot;response_headers&quot;,</span>
<span class="c1">// &quot;redirect_count&quot;, &quot;start_time&quot;, &quot;redirect_url&quot;, etc.</span>
<span class="nv">$httpInfo</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getInfo</span><span class="p">();</span>
<span class="c1">// you can get individual info too</span>
<span class="nv">$startTime</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getInfo</span><span class="p">(</span><span class="s1">&#39;start_time&#39;</span><span class="p">);</span>

<span class="c1">// returns detailed logs about the requests and responses of the HTTP transaction</span>
<span class="nv">$httpLogs</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getInfo</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal"><span class="pre">$response-&gt;getInfo()</span></code> is non-blocking: it returns <em>live</em> information
about the response. Some of them might not be known yet (e.g. <code class="docutils literal"><span class="pre">http_code</span></code>)
when you&#8217;ll call it.</p>
</div>
<div class="section" id="streaming-responses">
<span id="http-client-streaming-responses"></span><h3>Streaming Responses<a class="headerlink" href="#streaming-responses" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Call the <code class="docutils literal"><span class="pre">stream()</span></code> method of the HTTP client to get <em>chunks</em> of the
response sequentially instead of waiting for the entire response:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="nv">$url</span> <span class="o">=</span> <span class="s1">&#39;https://releases.ubuntu.com/18.04.1/ubuntu-18.04.1-desktop-amd64.iso&#39;</span><span class="p">;</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="nv">$url</span><span class="p">);</span>

<span class="c1">// Responses are lazy: this code is executed as soon as headers are received</span>
<span class="k">if</span> <span class="p">(</span><span class="mi">200</span> <span class="o">!==</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getStatusCode</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">\Exception</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// get the response contents in chunk and save them in a file</span>
<span class="c1">// response chunks implement Symfony\Contracts\HttpClient\ChunkInterface</span>
<span class="nv">$fileHandler</span> <span class="o">=</span> <span class="nb">fopen</span><span class="p">(</span><span class="s1">&#39;/ubuntu.iso&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">);</span>
<span class="k">foreach</span> <span class="p">(</span><span class="nv">$client</span><span class="o">-&gt;</span><span class="na">stream</span><span class="p">(</span><span class="nv">$response</span><span class="p">)</span> <span class="k">as</span> <span class="nv">$chunk</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">fwrite</span><span class="p">(</span><span class="nv">$fileHandler</span><span class="p">,</span> <span class="nv">$chunk</span><span class="o">-&gt;</span><span class="na">getContent</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">By default, <code class="docutils literal"><span class="pre">text/*</span></code>, JSON and XML response bodies are buffered in a local
<code class="docutils literal"><span class="pre">php://temp</span></code> stream. You can control this behavior by using the <code class="docutils literal"><span class="pre">buffer</span></code>
option: set it to <code class="docutils literal"><span class="pre">true</span></code>/<code class="docutils literal"><span class="pre">false</span></code> to enable/disable buffering, or to a
closure that should return the same based on the response headers it receives
as argument.</p>
</div>
</div>
<div class="section" id="canceling-responses">
<h3>Canceling Responses<a class="headerlink" href="#canceling-responses" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>To abort a request (e.g. because it didn&#8217;t complete in due time, or you want to
fetch only the first bytes of the response, etc.), you can either use the
<code class="docutils literal"><span class="pre">cancel()</span></code> method of <code class="docutils literal"><span class="pre">ResponseInterface</span></code>:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">cancel</span><span class="p">()</span>
</pre></div>
</div>
<p>Or throw an exception from a progress callback:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;https://...&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;on_progress&#39;</span> <span class="o">=&gt;</span> <span class="k">function</span> <span class="p">(</span><span class="nx">int</span> <span class="nv">$dlNow</span><span class="p">,</span> <span class="nx">int</span> <span class="nv">$dlSize</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$info</span><span class="p">)</span><span class="o">:</span> <span class="nx">void</span> <span class="p">{</span>
        <span class="c1">// ...</span>

        <span class="k">throw</span> <span class="k">new</span> <span class="nx">\MyException</span><span class="p">();</span>
    <span class="p">},</span>
<span class="p">]);</span>
</pre></div>
</div>
<p>The exception will be wrapped in an instance of <code class="docutils literal"><span class="pre">TransportExceptionInterface</span></code>
and will abort the request.</p>
<p>In case the response was canceled using <code class="docutils literal"><span class="pre">$response-&gt;cancel()</span></code>,
<code class="docutils literal"><span class="pre">$response-&gt;getInfo('canceled')</span></code> will return <code class="docutils literal"><span class="pre">true</span></code>.</p>
</div>
<div class="section" id="handling-exceptions">
<h3>Handling Exceptions<a class="headerlink" href="#handling-exceptions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>When the HTTP status code of the response is in the 300-599 range (i.e. 3xx,
4xx or 5xx) your code is expected to handle it. If you don&#8217;t do that, the
<code class="docutils literal"><span class="pre">getHeaders()</span></code> and <code class="docutils literal"><span class="pre">getContent()</span></code> methods throw an appropriate exception, all of
which implement the <code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Contracts/HttpClient/Exception/HttpExceptionInterface.html" title="Symfony\Contracts\HttpClient\Exception\HttpExceptionInterface"><span class="pre">HttpExceptionInterface</span></a></code>:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="c1">// the response of this request will be a 403 HTTP error</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;https://httpbin.org/status/403&#39;</span><span class="p">);</span>

<span class="c1">// this code results in a Symfony\Component\HttpClient\Exception\ClientException</span>
<span class="c1">// because it doesn&#39;t check the status code of the response</span>
<span class="nv">$content</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getContent</span><span class="p">();</span>

<span class="c1">// pass FALSE as the optional argument to not throw an exception and return</span>
<span class="c1">// instead the original response content (even if it&#39;s an error message)</span>
<span class="nv">$content</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getContent</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
</pre></div>
</div>
<p>While responses are lazy, their destructor will always wait for headers to come
back. This means that the following request <em>will</em> complete; and if e.g. a 404
is returned, an exception will be thrown:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="c1">// because the returned value is not assigned to a variable, the destructor</span>
<span class="c1">// of the returned response will be called immediately and will throw if the</span>
<span class="c1">// status code is in the 300-599 range</span>
<span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;https://...&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>This in turn means that unassigned responses will fallback to synchronous requests.
If you want to make these requests concurrent, you can store their corresponding
responses in an array:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="nv">$responses</span><span class="p">[]</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;https://.../path1&#39;</span><span class="p">);</span>
<span class="nv">$responses</span><span class="p">[]</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;https://.../path2&#39;</span><span class="p">);</span>
<span class="c1">// ...</span>

<span class="c1">// This line will trigger the destructor of all responses stored in the array;</span>
<span class="c1">// they will complete concurrently and an exception will be thrown in case a</span>
<span class="c1">// status code in the 300-599 range is returned</span>
<span class="nb">unset</span><span class="p">(</span><span class="nv">$responses</span><span class="p">);</span>
</pre></div>
</div>
<p>This behavior provided at destruction-time is part of the fail-safe design of the
component. No errors will be unnoticed: if you don&#8217;t write the code to handle
errors, exceptions will notify you when needed. On the other hand, if you write
the error-handling code, you will opt-out from these fallback mechanisms as the
destructor won&#8217;t have anything remaining to do.</p>
<p>There are three types of exceptions:</p>
<ul class="simple">
<li>Exceptions implementing the <code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Contracts/HttpClient/Exception/HttpExceptionInterface.html" title="Symfony\Contracts\HttpClient\Exception\HttpExceptionInterface"><span class="pre">HttpExceptionInterface</span></a></code>
are thrown when your code does not handle the status codes in the 300-599 range.</li>
<li>Exceptions implementing the <code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Contracts/HttpClient/Exception/TransportExceptionInterface.html" title="Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface"><span class="pre">TransportExceptionInterface</span></a></code>
are thrown when a lower level issue occurs.</li>
<li>Exceptions implementing the <code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Contracts/HttpClient/Exception/DecodingExceptionInterface.html" title="Symfony\Contracts\HttpClient\Exception\DecodingExceptionInterface"><span class="pre">DecodingExceptionInterface</span></a></code>
are thrown when a content-type cannot be decoded to the expected representation.</li>
</ul>
</div>
</div>
<div class="section" id="concurrent-requests">
<h2>Concurrent Requests<a class="headerlink" href="#concurrent-requests" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Thanks to responses being lazy, requests are always managed concurrently.
On a fast enough network, the following code makes 379 requests in less than
half a second when cURL is used:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\CurlHttpClient</span><span class="p">;</span>

<span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CurlHttpClient</span><span class="p">();</span>

<span class="nv">$responses</span> <span class="o">=</span> <span class="p">[];</span>

<span class="k">for</span> <span class="p">(</span><span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;</span> <span class="mi">379</span><span class="p">;</span> <span class="o">++</span><span class="nv">$i</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$uri</span> <span class="o">=</span> <span class="s2">&quot;https://http2.akamai.com/demo/tile-</span><span class="si">$i</span><span class="s2">.png&quot;</span><span class="p">;</span>
    <span class="nv">$responses</span><span class="p">[]</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="nv">$uri</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">foreach</span> <span class="p">(</span><span class="nv">$responses</span> <span class="k">as</span> <span class="nv">$response</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$content</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getContent</span><span class="p">();</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you can read in the first &#8220;for&#8221; loop, requests are issued but are not consumed
yet. That&#8217;s the trick when concurrency is desired: requests should be sent
first and be read later on. This will allow the client to monitor all pending
requests while your code waits for a specific one, as done in each iteration of
the above &#8220;foreach&#8221; loop.</p>
<div class="section" id="multiplexing-responses">
<h3>Multiplexing Responses<a class="headerlink" href="#multiplexing-responses" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>If you look again at the snippet above, responses are read in requests&#8217; order.
But maybe the 2nd response came back before the 1st? Fully asynchronous operations
require being able to deal with the responses in whatever order they come back.</p>
<p>In order to do so, the <code class="docutils literal"><span class="pre">stream()</span></code> method of HTTP clients accepts a list of
responses to monitor. As mentioned <a class="reference internal" href="#http-client-streaming-responses"><span>previously</span></a>,
this method yields response chunks as they arrive from the network. By replacing
the &#8220;foreach&#8221; in the snippet with this one, the code becomes fully async:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">foreach</span> <span class="p">(</span><span class="nv">$client</span><span class="o">-&gt;</span><span class="na">stream</span><span class="p">(</span><span class="nv">$responses</span><span class="p">)</span> <span class="k">as</span> <span class="nv">$response</span> <span class="o">=&gt;</span> <span class="nv">$chunk</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$chunk</span><span class="o">-&gt;</span><span class="na">isFirst</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// headers of $response just arrived</span>
        <span class="c1">// $response-&gt;getHeaders() is now a non-blocking call</span>
    <span class="p">}</span> <span class="k">elseif</span> <span class="p">(</span><span class="nv">$chunk</span><span class="o">-&gt;</span><span class="na">isLast</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// the full content of $response just completed</span>
        <span class="c1">// $response-&gt;getContent() is now a non-blocking call</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// $chunk-&gt;getContent() will return a piece</span>
        <span class="c1">// of the response body that just arrived</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="first admonition-title">ちなみに</p>
<p class="last">Use the <code class="docutils literal"><span class="pre">user_data</span></code> option combined with <code class="docutils literal"><span class="pre">$response-&gt;getInfo('user_data')</span></code>
to track the identity of the responses in your foreach loops.</p>
</div>
</div>
<div class="section" id="dealing-with-network-timeouts">
<h3>Dealing with Network Timeouts<a class="headerlink" href="#dealing-with-network-timeouts" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>This component allows dealing with both request and response timeouts.</p>
<p>A timeout can happen when e.g. DNS resolution takes too much time, when the TCP
connection cannot be opened in the given time budget, or when the response
content pauses for too long. This can be configured with the <code class="docutils literal"><span class="pre">timeout</span></code> request
option:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="c1">// A TransportExceptionInterface will be issued if nothing</span>
<span class="c1">// happens for 2.5 seconds when accessing from the $response</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;https://...&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;timeout&#39;</span> <span class="o">=&gt;</span> <span class="mf">2.5</span><span class="p">]);</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">default_socket_timeout</span></code> PHP ini setting is used if the option is not set.</p>
<p>The option can be overridden by using the 2nd argument of the <code class="docutils literal"><span class="pre">stream()</span></code> method.
This allows monitoring several responses at once and applying the timeout to all
of them in a group. If all responses become inactive for the given duration, the
method will yield a special chunk whose <code class="docutils literal"><span class="pre">isTimeout()</span></code> will return <code class="docutils literal"><span class="pre">true</span></code>:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">foreach</span> <span class="p">(</span><span class="nv">$client</span><span class="o">-&gt;</span><span class="na">stream</span><span class="p">(</span><span class="nv">$responses</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span> <span class="k">as</span> <span class="nv">$response</span> <span class="o">=&gt;</span> <span class="nv">$chunk</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$chunk</span><span class="o">-&gt;</span><span class="na">isTimeout</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// $response staled for more than 1.5 seconds</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A timeout is not necessarily an error: you can decide to stream again the
response and get remaining contents that might come back in a new timeout, etc.</p>
<div class="admonition tip">
<p class="first admonition-title">ちなみに</p>
<p class="last">Passing <code class="docutils literal"><span class="pre">0</span></code> as timeout allows monitoring responses in a non-blocking way.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>Timeouts control how long one is willing to wait <em>while the HTTP transaction
is idle</em>. Big responses can last as long as needed to complete, provided they
remain active during the transfer and never pause for longer than specified.</p>
<p class="last">Use the <code class="docutils literal"><span class="pre">max_duration</span></code> option to limit the time a full request/response can last.</p>
</div>
</div>
<div class="section" id="dealing-with-network-errors">
<h3>Dealing with Network Errors<a class="headerlink" href="#dealing-with-network-errors" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Network errors (broken pipe, failed DNS resolution, etc.) are thrown as instances
of <code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Contracts/HttpClient/Exception/TransportExceptionInterface.html" title="Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface"><span class="pre">TransportExceptionInterface</span></a></code>.</p>
<p>First of all, you don&#8217;t <em>have</em> to deal with them: letting errors bubble to your
generic exception-handling stack might be really fine in most use cases.</p>
<p>If you want to handle them, here is what you need to know:</p>
<p>To catch errors, you need to wrap calls to <code class="docutils literal"><span class="pre">$client-&gt;request()</span></code> but also calls
to any methods of the returned responses. This is because responses are lazy, so
that network errors can happen when calling e.g. <code class="docutils literal"><span class="pre">getStatusCode()</span></code> too:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="p">{</span>
    <span class="c1">// both lines can potentially throw</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
    <span class="nv">$headers</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getHeaders</span><span class="p">();</span>
    <span class="c1">// ...</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">TransportExceptionInterface</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Because <code class="docutils literal"><span class="pre">$response-&gt;getInfo()</span></code> is non-blocking, it shouldn&#8217;t throw by design.</p>
</div>
<p>When multiplexing responses, you can deal with errors for individual streams by
catching <code class="docutils literal"><span class="pre">TransportExceptionInterface</span></code> in the foreach loop:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">foreach</span> <span class="p">(</span><span class="nv">$client</span><span class="o">-&gt;</span><span class="na">stream</span><span class="p">(</span><span class="nv">$responses</span><span class="p">)</span> <span class="k">as</span> <span class="nv">$response</span> <span class="o">=&gt;</span> <span class="nv">$chunk</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$chunk</span><span class="o">-&gt;</span><span class="na">isTimeout</span><span class="p">())</span> <span class="p">{</span>
            <span class="c1">// ... decide what to do when a timeout occurs</span>
            <span class="c1">// if you want to stop a response that timed out, don&#39;t miss</span>
            <span class="c1">// calling $response-&gt;cancel() or the destructor of the response</span>
            <span class="c1">// will try to complete it one more time</span>
        <span class="p">}</span> <span class="k">elseif</span> <span class="p">(</span><span class="nv">$chunk</span><span class="o">-&gt;</span><span class="na">isFirst</span><span class="p">())</span> <span class="p">{</span>
            <span class="c1">// if you want to check the status code, you must do it when the</span>
            <span class="c1">// first chunk arrived, using $response-&gt;getStatusCode();</span>
            <span class="c1">// not doing so might trigger an HttpExceptionInterface</span>
        <span class="p">}</span> <span class="k">elseif</span> <span class="p">(</span><span class="nv">$chunk</span><span class="o">-&gt;</span><span class="na">isLast</span><span class="p">())</span> <span class="p">{</span>
            <span class="c1">// ... do something with $response</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">TransportExceptionInterface</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="caching-requests-and-responses">
<h2>Caching Requests and Responses<a class="headerlink" href="#caching-requests-and-responses" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>This component provides a <code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpClient/CachingHttpClient.html" title="Symfony\Component\HttpClient\CachingHttpClient"><span class="pre">CachingHttpClient</span></a></code>
decorator that allows caching responses and serving them from the local storage
for next requests. The implementation leverages the
<code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/HttpCache/HttpCache.html" title="Symfony\Component\HttpKernel\HttpCache\HttpCache"><span class="pre">HttpCache</span></a></code> class under the hood
so that the <a class="reference internal" href="http_kernel.html"><em>HttpKernel component</em></a> needs to be
installed in your application:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\CachingHttpClient</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\HttpClient</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpKernel\HttpCache\Store</span><span class="p">;</span>

<span class="nv">$store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Store</span><span class="p">(</span><span class="s1">&#39;/path/to/cache/storage/&#39;</span><span class="p">);</span>
<span class="nv">$client</span> <span class="o">=</span> <span class="nx">HttpClient</span><span class="o">::</span><span class="na">create</span><span class="p">();</span>
<span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CachingHttpClient</span><span class="p">(</span><span class="nv">$client</span><span class="p">,</span> <span class="nv">$store</span><span class="p">);</span>

<span class="c1">// this won&#39;t hit the network if the resource is already in the cache</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;https://example.com/cacheable-resource&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">CachingHttpClient</span></code> accepts a third argument to set the options of the <code class="docutils literal"><span class="pre">HttpCache</span></code>.</p>
</div>
<div class="section" id="scoping-client">
<h2>Scoping Client<a class="headerlink" href="#scoping-client" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>It&#8217;s common that some of the HTTP client options depend on the URL of the
request (e.g. you must set some headers when making requests to GitHub API but
not for other hosts). If that&#8217;s your case, this component provides a special
HTTP client via the <code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpClient/ScopingHttpClient.html" title="Symfony\Component\HttpClient\ScopingHttpClient"><span class="pre">ScopingHttpClient</span></a></code>
class to autoconfigure the HTTP client based on the requested URL:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\HttpClient</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\ScopingHttpClient</span><span class="p">;</span>

<span class="nv">$client</span> <span class="o">=</span> <span class="nx">HttpClient</span><span class="o">::</span><span class="na">create</span><span class="p">();</span>
<span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ScopingHttpClient</span><span class="p">(</span><span class="nv">$client</span><span class="p">,</span> <span class="p">[</span>
    <span class="c1">// the options defined as values apply only to the URLs matching</span>
    <span class="c1">// the regular expressions defined as keys</span>
    <span class="s1">&#39;https://api\.github\.com/&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;headers&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
            <span class="s1">&#39;Accept&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;application/vnd.github.v3+json&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Authorization&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;token &#39;</span><span class="o">.</span><span class="nv">$githubToken</span><span class="p">,</span>
        <span class="p">],</span>
    <span class="p">],</span>
    <span class="c1">// ...</span>
<span class="p">]);</span>
</pre></div>
</div>
<p>You can define several scopes, so that each set of options is added only if a
requested URL matches one of the regular expressions provided as keys.</p>
<p>If the request URL is relative (because you use the <code class="docutils literal"><span class="pre">base_uri</span></code> option), the
scoping HTTP client can&#8217;t make a match. That&#8217;s why you can define a third
optional argument in its constructor which will be considered the default
regular expression applied to relative URLs:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ScopingHttpClient</span><span class="p">(</span><span class="nv">$client</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="s1">&#39;https://api\.github\.com/&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
            <span class="s1">&#39;base_uri&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;https://api.github.com/&#39;</span><span class="p">,</span>
            <span class="c1">// ...</span>
        <span class="p">],</span>
    <span class="p">],</span>
    <span class="c1">// this is the index in the previous array that defines</span>
    <span class="c1">// the base URI that shoud be used to resolve relative URLs</span>
    <span class="s1">&#39;https://api\.github\.com/&#39;</span>
<span class="p">);</span>
</pre></div>
</div>
<p>The above example can be reduced to a simpler call:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="nv">$client</span> <span class="o">=</span> <span class="nx">ScopingHttpClient</span><span class="o">::</span><span class="na">forBaseUri</span><span class="p">(</span><span class="nv">$client</span><span class="p">,</span> <span class="s1">&#39;https://api.github.com/&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="c1">// ...</span>
<span class="p">]);</span>
</pre></div>
</div>
<p>This way, the provided options will be used only if the requested URL is relative
or if it matches the <code class="docutils literal"><span class="pre">https://api.github.com/</span></code> base URI.</p>
</div>
<div class="section" id="interoperability">
<h2>Interoperability<a class="headerlink" href="#interoperability" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The component is interoperable with four different abstractions for HTTP
clients: <a class="reference external" href="https://github.com/symfony/contracts">Symfony Contracts</a>, <a class="reference external" href="https://www.php-fig.org/psr/psr-18/">PSR-18</a>, <a class="reference external" href="https://github.com/php-http/httplug/#readme">HTTPlug</a> v1/v2 and native PHP streams.
If your application uses libraries that need any of them, the component is compatible
with all of them. They also benefit from <a class="reference internal" href="../service_container/autowiring.html#service-autowiring-alias"><span>autowiring aliases</span></a>
when the <a class="reference internal" href="../reference/configuration/framework.html#framework-bundle-configuration"><span>framework bundle</span></a> is used.</p>
<p>If you are writing or maintaining a library that makes HTTP requests, you can
decouple it from any specific HTTP client implementations by coding against
either Symfony Contracts (recommended), PSR-18 or HTTPlug v2.</p>
<div class="section" id="symfony-contracts">
<h3>Symfony Contracts<a class="headerlink" href="#symfony-contracts" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The interfaces found in the <code class="docutils literal"><span class="pre">symfony/http-client-contracts</span></code> package define
the primary abstractions implemented by the component. Its entry point is the
<code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Contracts/HttpClient/HttpClientInterface.html" title="Symfony\Contracts\HttpClient\HttpClientInterface"><span class="pre">HttpClientInterface</span></a></code>. That&#8217;s the
interface you need to code against when a client is needed:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Contracts\HttpClient\HttpClientInterface</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MyApiLayer</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="nv">$client</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nx">HttpClientInterface</span> <span class="nv">$client</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">client</span> <span class="o">=</span> <span class="nv">$client</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// [...]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>All request options mentioned above (e.g. timeout management) are also defined
in the wordings of the interface, so that any compliant implementations (like
this component) is guaranteed to provide them. That&#8217;s a major difference with
the other abstractions, which provide none related to the transport itself.</p>
<p>Another major feature covered by the Symfony Contracts is async/multiplexing,
as described in the previous sections.</p>
</div>
<div class="section" id="psr-18-and-psr-17">
<h3>PSR-18 and PSR-17<a class="headerlink" href="#psr-18-and-psr-17" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>This component implements the <a class="reference external" href="https://www.php-fig.org/psr/psr-18/">PSR-18</a> (HTTP Client) specifications via the
<code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpClient/Psr18Client.html" title="Symfony\Component\HttpClient\Psr18Client"><span class="pre">Psr18Client</span></a></code> class, which is an adapter
to turn a Symfony <code class="docutils literal"><span class="pre">HttpClientInterface</span></code> into a PSR-18 <code class="docutils literal"><span class="pre">ClientInterface</span></code>.
This class also implements the relevant methods of <a class="reference external" href="https://www.php-fig.org/psr/psr-17/">PSR-17</a> to ease creating
request objects.</p>
<p>To use it, you need the <code class="docutils literal"><span class="pre">psr/http-client</span></code> package and a <a class="reference external" href="https://www.php-fig.org/psr/psr-17/">PSR-17</a> implementation:</p>
<div class="highlight-terminal"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># installs the PSR-18 ClientInterface</span>
<span class="gp">$</span> composer require psr/http-client

<span class="c1"># installs an efficient implementation of response and stream factories</span>
<span class="c1"># with autowiring aliases provided by Symfony Flex</span>
<span class="gp">$</span> composer require nyholm/psr7

<span class="c1"># alternatively, install the php-http/discovery package to auto-discover</span>
<span class="c1"># any already installed implementations from common vendors:</span>
<span class="c1"># composer require php-http/discovery</span>
</pre></div>
</td></tr></table></div>
<p>Now you can make HTTP requests with the PSR-18 client as follows:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\Psr18Client</span><span class="p">;</span>

<span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Psr18Client</span><span class="p">();</span>

<span class="nv">$url</span> <span class="o">=</span> <span class="s1">&#39;https://symfony.com/versions.json&#39;</span><span class="p">;</span>
<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">createRequest</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="nv">$url</span><span class="p">);</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">sendRequest</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span>

<span class="nv">$content</span> <span class="o">=</span> <span class="nb">json_decode</span><span class="p">(</span><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getBody</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">getContents</span><span class="p">(),</span> <span class="k">true</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="httplug">
<h3>HTTPlug<a class="headerlink" href="#httplug" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The <a class="reference external" href="https://github.com/php-http/httplug/#readme">HTTPlug</a> v1 specification was published before PSR-18 and is superseded by
it. As such, you should not use it in newly written code. The component is still
interoperable with libraries that require it thanks to the
<code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpClient/HttplugClient.html" title="Symfony\Component\HttpClient\HttplugClient"><span class="pre">HttplugClient</span></a></code> class. Similarly to
<code class="docutils literal"><span class="pre">Psr18Client</span></code> implementing relevant parts of PSR-17, <code class="docutils literal"><span class="pre">HttplugClient</span></code> also
implements the factory methods defined in the related <code class="docutils literal"><span class="pre">php-http/message-factory</span></code>
package.</p>
<div class="highlight-terminal"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s suppose php-http/httplug is already required by the lib you want to use</span>

<span class="c1"># installs an efficient implementation of response and stream factories</span>
<span class="c1"># with autowiring aliases provided by Symfony Flex</span>
<span class="gp">$</span> composer require nyholm/psr7

<span class="c1"># alternatively, install the php-http/discovery package to auto-discover</span>
<span class="c1"># any already installed implementations from common vendors:</span>
<span class="c1"># composer require php-http/discovery</span>
</pre></div>
</td></tr></table></div>
<p>Let&#8217;s say you want to instantiate a class with the following constructor,
that requires HTTPlug dependencies:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Http\Client\HttpClient</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Http\Message\RequestFactory</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Http\Message\StreamFactory</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">SomeSdk</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span>
        <span class="nx">HttpClient</span> <span class="nv">$httpClient</span><span class="p">,</span>
        <span class="nx">RequestFactory</span> <span class="nv">$requestFactory</span><span class="p">,</span>
        <span class="nx">StreamFactory</span> <span class="nv">$streamFactory</span>
    <span class="p">)</span>
    <span class="c1">// [...]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Because <code class="docutils literal"><span class="pre">HttplugClient</span></code> implements the three interfaces, you can use it this way:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\HttplugClient</span><span class="p">;</span>

<span class="nv">$httpClient</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">HttplugClient</span><span class="p">();</span>
<span class="nv">$apiClient</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SomeSdk</span><span class="p">(</span><span class="nv">$httpClient</span><span class="p">,</span> <span class="nv">$httpClient</span><span class="p">,</span> <span class="nv">$httpClient</span><span class="p">);</span>
</pre></div>
</div>
<p>If you&#8217;d like to work with promises, <code class="docutils literal"><span class="pre">HttplugClient</span></code> also implements the
<code class="docutils literal"><span class="pre">HttpAsyncClient</span></code> interface. To use it, you need to install the
<code class="docutils literal"><span class="pre">guzzlehttp/promises</span></code> package:</p>
<div class="highlight-terminal"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">$</span> composer require guzzlehttp/promises
</pre></div>
</td></tr></table></div>
<p>Then you&#8217;re ready to go:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Psr\Http\Message\ResponseInterface</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\HttplugClient</span><span class="p">;</span>

<span class="nv">$httpClient</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">HttplugClient</span><span class="p">();</span>
<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$httpClient</span><span class="o">-&gt;</span><span class="na">createRequest</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;https://my.api.com/&#39;</span><span class="p">);</span>
<span class="nv">$promise</span> <span class="o">=</span> <span class="nv">$httpClient</span><span class="o">-&gt;</span><span class="na">sendRequest</span><span class="p">(</span><span class="nv">$request</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">then</span><span class="p">(</span>
        <span class="k">function</span> <span class="p">(</span><span class="nx">ResponseInterface</span> <span class="nv">$response</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">echo</span> <span class="s1">&#39;Got status &#39;</span><span class="o">.</span><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getStatusCode</span><span class="p">();</span>

            <span class="k">return</span> <span class="nv">$response</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="k">function</span> <span class="p">(</span><span class="nx">\Throwable</span> <span class="nv">$exception</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">echo</span> <span class="s1">&#39;Error: &#39;</span><span class="o">.</span><span class="nv">$exception</span><span class="o">-&gt;</span><span class="na">getMessage</span><span class="p">();</span>

            <span class="k">throw</span> <span class="nv">$exception</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">);</span>

<span class="c1">// after you&#39;re done with sending several requests,</span>
<span class="c1">// you must wait for them to complete concurrently</span>

<span class="c1">// wait for a specific promise to resolve while monitoring them all</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$promise</span><span class="o">-&gt;</span><span class="na">wait</span><span class="p">();</span>

<span class="c1">// wait maximum 1 second for pending promises to resolve</span>
<span class="nv">$httpClient</span><span class="o">-&gt;</span><span class="na">wait</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>

<span class="c1">// wait for all remaining promises to resolve</span>
<span class="nv">$httpClient</span><span class="o">-&gt;</span><span class="na">wait</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="native-php-streams">
<h3>Native PHP Streams<a class="headerlink" href="#native-php-streams" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Responses implementing <code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Contracts/HttpClient/ResponseInterface.html" title="Symfony\Contracts\HttpClient\ResponseInterface"><span class="pre">ResponseInterface</span></a></code>
can be cast to native PHP streams with
<code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpClient/Response/StreamWrapper.html#method_createResource" title="Symfony\Component\HttpClient\Response\StreamWrapper::createResource()"><span class="pre">createResource()</span></a></code>.
This allows using them where native PHP streams are needed:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\HttpClient</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\Response\StreamWrapper</span><span class="p">;</span>

<span class="nv">$client</span> <span class="o">=</span> <span class="nx">HttpClient</span><span class="o">::</span><span class="na">create</span><span class="p">();</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;https://symfony.com/versions.json&#39;</span><span class="p">);</span>

<span class="nv">$streamResource</span> <span class="o">=</span> <span class="nx">StreamWrapper</span><span class="o">::</span><span class="na">createResource</span><span class="p">(</span><span class="nv">$response</span><span class="p">,</span> <span class="nv">$client</span><span class="p">);</span>

<span class="c1">// alternatively and contrary to the previous one, this returns</span>
<span class="c1">// a resource that is seekable and potentially stream_select()-able</span>
<span class="nv">$streamResource</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">toStream</span><span class="p">();</span>

<span class="k">echo</span> <span class="nb">stream_get_contents</span><span class="p">(</span><span class="nv">$streamResource</span><span class="p">);</span> <span class="c1">// outputs the content of the response</span>

<span class="c1">// later on if you need to, you can access the response from the stream</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nb">stream_get_meta_data</span><span class="p">(</span><span class="nv">$streamResource</span><span class="p">)[</span><span class="s1">&#39;wrapper_data&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">getResponse</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="symfony-framework-integration">
<h2>Symfony Framework Integration<a class="headerlink" href="#symfony-framework-integration" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>When using this component in a full-stack Symfony application, you can configure
multiple clients with different configurations and inject them into your services.</p>
<div class="section" id="configuration">
<h3>Configuration<a class="headerlink" href="#configuration" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Use the <code class="docutils literal"><span class="pre">framework.http_client</span></code> key to configure the default HTTP client used
in the application. Check out the full
<a class="reference internal" href="../reference/configuration/framework.html#reference-http-client"><span>http_client config reference</span></a> to learn about all
the available config options:</p>
<div class="highlight-yaml"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># config/packages/framework.yaml</span>
<span class="l l-Scalar l-Scalar-Plain">framework</span><span class="p p-Indicator">:</span>
    <span class="c1"># ...</span>
    <span class="l l-Scalar l-Scalar-Plain">http_client</span><span class="p p-Indicator">:</span>
        <span class="l l-Scalar l-Scalar-Plain">max_host_connections</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">10</span>
        <span class="l l-Scalar l-Scalar-Plain">default_options</span><span class="p p-Indicator">:</span>
            <span class="l l-Scalar l-Scalar-Plain">max_redirects</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">7</span>
</pre></div>
</td></tr></table></div>
<p>If you want to define multiple HTTP clients, use this other expanded configuration:</p>
<div class="highlight-yaml"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># config/packages/framework.yaml</span>
<span class="l l-Scalar l-Scalar-Plain">framework</span><span class="p p-Indicator">:</span>
    <span class="c1"># ...</span>
    <span class="l l-Scalar l-Scalar-Plain">http_client</span><span class="p p-Indicator">:</span>
        <span class="l l-Scalar l-Scalar-Plain">scoped_clients</span><span class="p p-Indicator">:</span>
            <span class="l l-Scalar l-Scalar-Plain">crawler.client</span><span class="p p-Indicator">:</span>
                <span class="l l-Scalar l-Scalar-Plain">headers</span><span class="p p-Indicator">:</span> <span class="p p-Indicator">{</span> <span class="s">&#39;X-Powered-By&#39;</span><span class="p p-Indicator">:</span> <span class="s">&#39;ACME</span><span class="nv"> </span><span class="s">App&#39;</span> <span class="p p-Indicator">}</span>
                <span class="l l-Scalar l-Scalar-Plain">http_version</span><span class="p p-Indicator">:</span> <span class="s">&#39;1.0&#39;</span>
            <span class="l l-Scalar l-Scalar-Plain">some_api.client</span><span class="p p-Indicator">:</span>
                <span class="l l-Scalar l-Scalar-Plain">max_redirects</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">5</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="injecting-the-http-client-into-services">
<h3>Injecting the HTTP Client into Services<a class="headerlink" href="#injecting-the-http-client-into-services" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>If your application only needs one HTTP client, you can inject the default one
into any services by type-hinting a constructor argument with the
<code class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Contracts/HttpClient/HttpClientInterface.html" title="Symfony\Contracts\HttpClient\HttpClientInterface"><span class="pre">HttpClientInterface</span></a></code>:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Contracts\HttpClient\HttpClientInterface</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">SomeService</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="nv">$client</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nx">HttpClientInterface</span> <span class="nv">$client</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">client</span> <span class="o">=</span> <span class="nv">$client</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you have several clients, you must use any of the methods defined by Symfony
to <a class="reference internal" href="../service_container.html#services-wire-specific-service"><span>choose a specific service</span></a>. Each client
has a unique service named after its configuration.</p>
<p>Each scoped client also defines a corresponding named autowiring alias.
If you use for example
<code class="docutils literal"><span class="pre">Symfony\Contracts\HttpClient\HttpClientInterface</span> <span class="pre">$myApiClient</span></code>
as the type and name of an argument, autowiring will inject the <code class="docutils literal"><span class="pre">my_api.client</span></code>
service into your autowired classes.</p>
</div>
</div>
<div class="section" id="testing-http-clients-and-responses">
<h2>Testing HTTP Clients and Responses<a class="headerlink" href="#testing-http-clients-and-responses" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>This component includes the <code class="docutils literal"><span class="pre">MockHttpClient</span></code> and <code class="docutils literal"><span class="pre">MockResponse</span></code> classes to
use them in tests that need an HTTP client which doesn&#8217;t make actual HTTP
requests.</p>
<p>The first way of using <code class="docutils literal"><span class="pre">MockHttpClient</span></code> is to pass a list of responses to its
constructor. These will be yielded in order when requests are made:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\MockHttpClient</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\Response\MockResponse</span><span class="p">;</span>

<span class="nv">$responses</span> <span class="o">=</span> <span class="p">[</span>
    <span class="k">new</span> <span class="nx">MockResponse</span><span class="p">(</span><span class="nv">$body1</span><span class="p">,</span> <span class="nv">$info1</span><span class="p">),</span>
    <span class="k">new</span> <span class="nx">MockResponse</span><span class="p">(</span><span class="nv">$body2</span><span class="p">,</span> <span class="nv">$info2</span><span class="p">),</span>
<span class="p">];</span>

<span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MockHttpClient</span><span class="p">(</span><span class="nv">$responses</span><span class="p">);</span>
<span class="c1">// responses are returned in the same order as passed to MockHttpClient</span>
<span class="nv">$response1</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">);</span> <span class="c1">// returns $responses[0]</span>
<span class="nv">$response2</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">);</span> <span class="c1">// returns $responses[1]</span>
</pre></div>
</div>
<p>Another way of using <code class="docutils literal"><span class="pre">MockHttpClient</span></code> is to pass a callback that generates the
responses dynamically when it&#8217;s called:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\MockHttpClient</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpClient\Response\MockResponse</span><span class="p">;</span>

<span class="nv">$callback</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$method</span><span class="p">,</span> <span class="nv">$url</span><span class="p">,</span> <span class="nv">$options</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">MockResponse</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">);</span>
<span class="p">};</span>

<span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MockHttpClient</span><span class="p">(</span><span class="nv">$callback</span><span class="p">);</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">);</span> <span class="c1">// calls $callback to get the response</span>
</pre></div>
</div>
<p>The responses provided to the mock client don&#8217;t have to be instances of
<code class="docutils literal"><span class="pre">MockResponse</span></code>. Any class implementing <code class="docutils literal"><span class="pre">ResponseInterface</span></code> will work (e.g.
<code class="docutils literal"><span class="pre">$this-&gt;createMock(ResponseInterface::class)</span></code>).</p>
<p>However, using <code class="docutils literal"><span class="pre">MockResponse</span></code> allows simulating chunked responses and timeouts:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="nv">$body</span> <span class="o">=</span> <span class="k">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
    <span class="c1">// empty strings are turned into timeouts so that they are easy to test</span>
    <span class="k">yield</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="k">yield</span> <span class="s1">&#39;world&#39;</span><span class="p">;</span>
<span class="p">};</span>

<span class="nv">$mockResponse</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MockResponse</span><span class="p">(</span><span class="nv">$body</span><span class="p">());</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="http_foundation.html" class="btn btn-neutral float-right" title="The HttpFoundation Component" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../form/data_based_validation.html" class="btn btn-neutral" title="How to Choose Validation Groups Based on the Submitted Data" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright .

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            LANGUAGE:'ja',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>