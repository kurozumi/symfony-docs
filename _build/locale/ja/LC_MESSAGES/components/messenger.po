# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Symfony Framework
# Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Symfony Framework Documentation \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-08 14:21+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../../../components/messenger.rst:6
msgid "The Messenger Component"
msgstr ""

#: ../../../components/messenger.rst:8
msgid ""
"The Messenger component helps applications send and receive messages "
"to/from other applications or via message queues."
msgstr ""

#: ../../../components/messenger.rst:11
msgid ""
"The component is greatly inspired by Matthias Noback's series of `blog "
"posts about command buses`_ and the `SimpleBus project`_."
msgstr ""

#: ../../../components/messenger.rst:16
msgid ""
"This article explains how to use the Messenger features as an independent"
" component in any PHP application. Read the :doc:`/messenger` article to "
"learn about how to use it in Symfony applications."
msgstr ""

#: ../../../components/messenger.rst:21
msgid "Installation"
msgstr ""

#: ../../../components/require_autoload.rst.inc:3
msgid ""
"If you install this component outside of a Symfony application, you must "
"require the ``vendor/autoload.php`` file in your code to enable the class"
" autoloading mechanism provided by Composer. Read :doc:`this article "
"</components/using_components>` for more details."
msgstr ""

#: ../../../components/messenger.rst:30
msgid "Concepts"
msgstr ""

#: ../../../components/messenger.rst:38
msgid "**Sender**:"
msgstr ""

#: ../../../components/messenger.rst:37
msgid ""
"Responsible for serializing and sending messages to *something*. This "
"something can be a message broker or a third party API for example."
msgstr ""

#: ../../../components/messenger.rst:42
msgid "**Receiver**:"
msgstr ""

#: ../../../components/messenger.rst:41
msgid ""
"Responsible for retrieving, deserializing and forwarding messages to "
"handler(s). This can be a message queue puller or an API endpoint for "
"example."
msgstr ""

#: ../../../components/messenger.rst:46
msgid "**Handler**:"
msgstr ""

#: ../../../components/messenger.rst:45
msgid ""
"Responsible for handling messages using the business logic applicable to "
"the messages. Handlers are called by the ``HandleMessageMiddleware`` "
"middleware."
msgstr ""

#: ../../../components/messenger.rst:59
msgid "**Middleware**:"
msgstr ""

#: ../../../components/messenger.rst:49
msgid ""
"Middleware can access the message and its wrapper (the envelope) while it"
" is dispatched through the bus. Literally *\"the software in the "
"middle\"*, those are not about core concerns (business logic) of an "
"application. Instead, they are cross cutting concerns applicable "
"throughout the application and affecting the entire message bus. For "
"instance: logging, validating a message, starting a transaction, ... They"
" are also responsible for calling the next middleware in the chain, which"
" means they can tweak the envelope, by adding stamps to it or even "
"replacing it, as well as interrupt the middleware chain. Middleware are "
"called both when a message is originally dispatched and again later when "
"a message is received from a transport,"
msgstr ""

#: ../../../components/messenger.rst:64
msgid "**Envelope**:"
msgstr ""

#: ../../../components/messenger.rst:62
msgid ""
"Messenger specific concept, it gives full flexibility inside the message "
"bus, by wrapping the messages into it, allowing to add useful information"
" inside through *envelope stamps*."
msgstr ""

#: ../../../components/messenger.rst:69
msgid "**Envelope Stamps**:"
msgstr ""

#: ../../../components/messenger.rst:67
msgid ""
"Piece of information you need to attach to your message: serializer "
"context to use for transport, markers identifying a received message or "
"any sort of metadata your middleware or transport layer may use."
msgstr ""

#: ../../../components/messenger.rst:72
msgid "Bus"
msgstr ""

#: ../../../components/messenger.rst:74
msgid ""
"The bus is used to dispatch messages. The behavior of the bus is in its "
"ordered middleware stack. The component comes with a set of middleware "
"that you can use."
msgstr ""

#: ../../../components/messenger.rst:77
msgid ""
"When using the message bus with Symfony's FrameworkBundle, the following "
"middleware are configured for you:"
msgstr ""

#: ../../../components/messenger.rst:80
msgid ""
":class:`Symfony\\\\Component\\\\Messenger\\\\Middleware\\\\SendMessageMiddleware`"
" (enables asynchronous processing, logs the processing of your messages "
"if you pass a logger)"
msgstr ""

#: ../../../components/messenger.rst:81
msgid ""
":class:`Symfony\\\\Component\\\\Messenger\\\\Middleware\\\\HandleMessageMiddleware`"
" (calls the registered handler(s))"
msgstr ""

#: ../../../components/messenger.rst:83
msgid "Example::"
msgstr ""

#: ../../../components/messenger.rst:103
msgid ""
"Every middleware needs to implement the "
":class:`Symfony\\\\Component\\\\Messenger\\\\Middleware\\\\MiddlewareInterface`."
msgstr ""

#: ../../../components/messenger.rst:106
msgid "Handlers"
msgstr ""

#: ../../../components/messenger.rst:108
msgid ""
"Once dispatched to the bus, messages will be handled by a \"message "
"handler\". A message handler is a PHP callable (i.e. a function or an "
"instance of a class) that will do the required processing for your "
"message::"
msgstr ""

#: ../../../components/messenger.rst:127
msgid "Adding Metadata to Messages (Envelopes)"
msgstr ""

#: ../../../components/messenger.rst:129
msgid ""
"If you need to add metadata or some configuration to a message, wrap it "
"with the :class:`Symfony\\\\Component\\\\Messenger\\\\Envelope` class and"
" add stamps. For example, to set the serialization groups used when the "
"message goes through the transport layer, use the ``SerializerStamp`` "
"stamp::"
msgstr ""

#: ../../../components/messenger.rst:145
msgid ""
"At the moment, the Symfony Messenger has the following built-in envelope "
"stamps:"
msgstr ""

#: ../../../components/messenger.rst:147
msgid ""
":class:`Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\SerializerStamp`, "
"to configure the serialization groups used by the transport."
msgstr ""

#: ../../../components/messenger.rst:149
msgid ""
":class:`Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\ValidationStamp`, "
"to configure the validation groups used when the validation middleware is"
" enabled."
msgstr ""

#: ../../../components/messenger.rst:151
msgid ""
":class:`Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\ReceivedStamp`, an "
"internal stamp that marks the message as received from a transport."
msgstr ""

#: ../../../components/messenger.rst:153
msgid ""
":class:`Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\SentStamp`, a stamp"
" that marks the message as sent by a specific sender. Allows accessing "
"the sender FQCN and the alias if available from the "
":class:`Symfony\\\\Component\\\\Messenger\\\\Transport\\\\Sender\\\\SendersLocator`."
msgstr ""

#: ../../../components/messenger.rst:157
msgid ""
":class:`Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\HandledStamp`, a "
"stamp that marks the message as handled by a specific handler. Allows "
"accessing the handler returned value and the handler name."
msgstr ""

#: ../../../components/messenger.rst:161
msgid ""
"Instead of dealing directly with the messages in the middleware you "
"receive the envelope. Hence you can inspect the envelope content and its "
"stamps, or add any::"
msgstr ""

#: ../../../components/messenger.rst:187
msgid ""
"The above example will forward the message to the next middleware with an"
" additional stamp *if* the message has just been received (i.e. has at "
"least one ``ReceivedStamp`` stamp). You can create your own stamps by "
"implementing "
":class:`Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\StampInterface`."
msgstr ""

#: ../../../components/messenger.rst:192
msgid ""
"If you want to examine all stamps on an envelope, use the "
"``$envelope->all()`` method, which returns all stamps grouped by type "
"(FQCN). Alternatively, you can iterate through all stamps of a specific "
"type by using the FQCN as first parameter of this method (e.g. "
"``$envelope->all(ReceivedStamp::class)``)."
msgstr ""

#: ../../../components/messenger.rst:199
msgid ""
"Any stamp must be serializable using the Symfony Serializer component if "
"going through transport using the "
":class:`Symfony\\\\Component\\\\Messenger\\\\Transport\\\\Serialization\\\\Serializer`"
" base serializer."
msgstr ""

#: ../../../components/messenger.rst:204
msgid "Transports"
msgstr ""

#: ../../../components/messenger.rst:206
msgid ""
"In order to send and receive messages, you will have to configure a "
"transport. A transport will be responsible for communicating with your "
"message broker or 3rd parties."
msgstr ""

#: ../../../components/messenger.rst:210
msgid "Your own Sender"
msgstr ""

#: ../../../components/messenger.rst:212
msgid ""
"Imagine that you already have an ``ImportantAction`` message going "
"through the message bus and being handled by a handler. Now, you also "
"want to send this message as an email (using the :doc:`Mime "
"</components/mime>` and :doc:`Mailer </components/mailer>` components)."
msgstr ""

#: ../../../components/messenger.rst:217
msgid ""
"Using the "
":class:`Symfony\\\\Component\\\\Messenger\\\\Transport\\\\Sender\\\\SenderInterface`,"
" you can create your own message sender::"
msgstr ""

#: ../../../components/messenger.rst:259
msgid "Your own Receiver"
msgstr ""

#: ../../../components/messenger.rst:261
msgid ""
"A receiver is responsible for getting messages from a source and "
"dispatching them to the application."
msgstr ""

#: ../../../components/messenger.rst:264
msgid ""
"Imagine you already processed some \"orders\" in your application using a"
" ``NewOrder`` message. Now you want to integrate with a 3rd party or a "
"legacy application but you can't use an API and need to use a shared CSV "
"file with new orders."
msgstr ""

#: ../../../components/messenger.rst:269
msgid ""
"You will read this CSV file and dispatch a ``NewOrder`` message. All you "
"need to do is to write your own CSV receiver::"
msgstr ""

#: ../../../components/messenger.rst:325
msgid "Receiver and Sender on the same Bus"
msgstr ""

#: ../../../components/messenger.rst:327
msgid ""
"To allow sending and receiving messages on the same bus and prevent an "
"infinite loop, the message bus will add a "
":class:`Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\ReceivedStamp` "
"stamp to the message envelopes and the "
":class:`Symfony\\\\Component\\\\Messenger\\\\Middleware\\\\SendMessageMiddleware`"
" middleware will know it should not route these messages again to a "
"transport."
msgstr ""

#: ../../../components/messenger.rst:333
msgid "Learn more"
msgstr ""

