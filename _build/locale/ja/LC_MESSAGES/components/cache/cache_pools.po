# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Symfony Framework
# Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Symfony Framework Documentation \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-08 14:21+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../../../components/cache/cache_pools.rst:15
msgid "Cache Pools and Supported Adapters"
msgstr ""

#: ../../../components/cache/cache_pools.rst:17
msgid ""
"Cache Pools are the logical repositories of cache items. They perform all"
" the common operations on items, such as saving them or looking for them."
" Cache pools are independent of the actual cache implementation. "
"Therefore, applications can keep using the same cache pool even if the "
"underlying cache mechanism changes from a file system based cache to a "
"Redis or database based cache."
msgstr ""

#: ../../../components/cache/cache_pools.rst:26
msgid "Creating Cache Pools"
msgstr ""

#: ../../../components/cache/cache_pools.rst:28
msgid ""
"Cache Pools are created through the **cache adapters**, which are classes"
" that implement both "
":class:`Symfony\\\\Contracts\\\\Cache\\\\CacheInterface` and "
"``Psr\\Cache\\CacheItemPoolInterface``. This component provides several "
"adapters ready to use in your applications."
msgstr ""

#: ../../../components/cache/cache_pools.rst:41
msgid "Using the Cache Contracts"
msgstr ""

#: ../../../components/cache/cache_pools.rst:43
msgid ""
"The :class:`Symfony\\\\Contracts\\\\Cache\\\\CacheInterface` allows "
"fetching, storing and deleting cache items using only two methods and a "
"callback::"
msgstr ""

#: ../../../components/cache/cache_pools.rst:66
msgid ""
"Out of the box, using this interface provides stampede protection via "
"locking and early expiration. Early expiration can be controlled via the "
"third \"beta\" argument of the "
":method:`Symfony\\\\Contracts\\\\Cache\\\\CacheInterface::get` method. "
"See the :doc:`/components/cache` article for more information."
msgstr ""

#: ../../../components/cache/cache_pools.rst:71
msgid ""
"Early expiration can be detected inside the callback by calling the "
":method:`Symfony\\\\Contracts\\\\Cache\\\\ItemInterface::isHit` method: "
"if this returns ``true``, it means we are currently recomputing a value "
"ahead of its expiration date."
msgstr ""

#: ../../../components/cache/cache_pools.rst:76
msgid ""
"For advanced use cases, the callback can accept a second ``bool &$save`` "
"argument passed by reference. By setting ``$save`` to ``false`` inside "
"the callback, you can instruct the cache pool that the returned value "
"*should not* be stored in the backend."
msgstr ""

#: ../../../components/cache/cache_pools.rst:82
msgid "Using PSR-6"
msgstr ""

#: ../../../components/cache/cache_pools.rst:85
msgid "Looking for Cache Items"
msgstr ""

#: ../../../components/cache/cache_pools.rst:87
msgid ""
"Cache Pools define three methods to look for cache items. The most common"
" method is ``getItem($key)``, which returns the cache item identified by "
"the given key::"
msgstr ""

#: ../../../components/cache/cache_pools.rst:95
msgid ""
"If no item is defined for the given key, the method doesn't return a "
"``null`` value but an empty object which implements the "
":class:`Symfony\\\\Component\\\\Cache\\\\CacheItem` class."
msgstr ""

#: ../../../components/cache/cache_pools.rst:99
msgid ""
"If you need to fetch several cache items simultaneously, use instead the "
"``getItems([$key1, $key2, ...])`` method::"
msgstr ""

#: ../../../components/cache/cache_pools.rst:105
msgid ""
"Again, if any of the keys doesn't represent a valid cache item, you won't"
" get a ``null`` value but an empty ``CacheItem`` object."
msgstr ""

#: ../../../components/cache/cache_pools.rst:108
msgid ""
"The last method related to fetching cache items is ``hasItem($key)``, "
"which returns ``true`` if there is a cache item identified by the given "
"key::"
msgstr ""

#: ../../../components/cache/cache_pools.rst:115
msgid "Saving Cache Items"
msgstr ""

#: ../../../components/cache/cache_pools.rst:117
msgid ""
"The most common method to save cache items is "
"``Psr\\Cache\\CacheItemPoolInterface::save``, which stores the item in "
"the cache immediately (it returns ``true`` if the item was saved or "
"``false`` if some error occurred)::"
msgstr ""

#: ../../../components/cache/cache_pools.rst:127
msgid ""
"Sometimes you may prefer to not save the objects immediately in order to "
"increase the application performance. In those cases, use the "
"``Psr\\Cache\\CacheItemPoolInterface::saveDeferred`` method to mark cache"
" items as \"ready to be persisted\" and then call to "
"``Psr\\Cache\\CacheItemPoolInterface::commit`` method when you are ready "
"to persist them all::"
msgstr ""

#: ../../../components/cache/cache_pools.rst:143
msgid ""
"The ``saveDeferred()`` method returns ``true`` when the cache item has "
"been successfully added to the \"persist queue\" and ``false`` otherwise."
" The ``commit()`` method returns ``true`` when all the pending items are "
"successfully saved or ``false`` otherwise."
msgstr ""

#: ../../../components/cache/cache_pools.rst:149
msgid "Removing Cache Items"
msgstr ""

#: ../../../components/cache/cache_pools.rst:151
msgid ""
"Cache Pools include methods to delete a cache item, some of them or all "
"of them. The most common is "
"``Psr\\Cache\\CacheItemPoolInterface::deleteItem``, which deletes the "
"cache item identified by the given key (it returns ``true`` when the item"
" is successfully deleted or doesn't exist and ``false`` otherwise)::"
msgstr ""

#: ../../../components/cache/cache_pools.rst:159
msgid ""
"Use the ``Psr\\Cache\\CacheItemPoolInterface::deleteItems`` method to "
"delete several cache items simultaneously (it returns ``true`` only if "
"all the items have been deleted, even when any or some of them don't "
"exist)::"
msgstr ""

#: ../../../components/cache/cache_pools.rst:166
msgid ""
"Finally, to remove all the cache items stored in the pool, use the "
"``Psr\\Cache\\CacheItemPoolInterface::clear`` method (which returns "
"``true`` when all items are successfully deleted)::"
msgstr ""

#: ../../../components/cache/cache_pools.rst:175
msgid ""
"If the cache component is used inside a Symfony application, you can "
"remove items from cache pools using the following commands (which reside "
"within the :ref:`framework bundle <framework-bundle-configuration>`):"
msgstr ""

#: ../../../components/cache/cache_pools.rst:179
msgid "To remove *one specific item* from the *given pool*:"
msgstr ""

#: ../../../components/cache/cache_pools.rst:188
msgid "You can also remove *all items* from the *given pool(s)*:"
msgstr ""

#: ../../../components/cache/cache_pools.rst:203
msgid "Pruning Cache Items"
msgstr ""

#: ../../../components/cache/cache_pools.rst:205
msgid ""
"Some cache pools do not include an automated mechanism for pruning "
"expired cache items. For example, the :ref:`FilesystemAdapter <component-"
"cache-filesystem-adapter>` cache does not remove expired cache items "
"*until an item is explicitly requested and determined to be expired*, for"
" example, via a call to ``Psr\\Cache\\CacheItemPoolInterface::getItem``. "
"Under certain workloads, this can cause stale cache entries to persist "
"well past their expiration, resulting in a sizable consumption of wasted "
"disk or memory space from excess, expired cache items."
msgstr ""

#: ../../../components/cache/cache_pools.rst:213
msgid ""
"This shortcoming has been solved through the introduction of "
":class:`Symfony\\\\Component\\\\Cache\\\\PruneableInterface`, which "
"defines the abstract method "
":method:`Symfony\\\\Component\\\\Cache\\\\PruneableInterface::prune`. The"
" :ref:`ChainAdapter <component-cache-chain-adapter>`, "
":ref:`FilesystemAdapter <component-cache-filesystem-adapter>`, "
":ref:`PdoAdapter <pdo-doctrine-adapter>`, and :ref:`PhpFilesAdapter "
"<component-cache-files-adapter>` all implement this new interface, "
"allowing manual removal of stale cache items::"
msgstr ""

#: ../../../components/cache/cache_pools.rst:228
msgid ""
"The :ref:`ChainAdapter <component-cache-chain-adapter>` implementation "
"does not directly contain any pruning logic itself. Instead, when calling"
" the chain adapter's "
":method:`Symfony\\\\Component\\\\Cache\\\\Adapter\\\\ChainAdapter::prune`"
" method, the call is delegated to all its compatible cache adapters (and "
"those that do not implement ``PruneableInterface`` are silently "
"ignored)::"
msgstr ""

#: ../../../components/cache/cache_pools.rst:254
msgid ""
"If the cache component is used inside a Symfony application, you can "
"prune *all items* from *all pools* using the following command (which "
"resides within the :ref:`framework bundle <framework-bundle-"
"configuration>`):"
msgstr ""

