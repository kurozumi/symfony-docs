# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Symfony Framework
# Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Symfony Framework Documentation \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-08 14:21+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../../../components/options_resolver.rst:6
msgid "The OptionsResolver Component"
msgstr ""

#: ../../../components/options_resolver.rst:8
msgid ""
"The OptionsResolver component is an improved replacement for the "
":phpfunction:`array_replace` PHP function. It allows you to create an "
"options system with required options, defaults, validation (type, value),"
" normalization and more."
msgstr ""

#: ../../../components/options_resolver.rst:14
msgid "Installation"
msgstr ""

#: ../../../components/require_autoload.rst.inc:3
msgid ""
"If you install this component outside of a Symfony application, you must "
"require the ``vendor/autoload.php`` file in your code to enable the class"
" autoloading mechanism provided by Composer. Read :doc:`this article "
"</components/using_components>` for more details."
msgstr ""

#: ../../../components/options_resolver.rst:23
msgid "Usage"
msgstr ""

#: ../../../components/options_resolver.rst:25
msgid ""
"Imagine you have a ``Mailer`` class which has four options: ``host``, "
"``username``, ``password`` and ``port``::"
msgstr ""

#: ../../../components/options_resolver.rst:38
msgid ""
"When accessing the ``$options``, you need to add some boilerplate code to"
" check which options are set::"
msgstr ""

#: ../../../components/options_resolver.rst:57
msgid ""
"Also, the default values of the options are buried in the business logic "
"of your code. Use the :phpfunction:`array_replace` to fix that::"
msgstr ""

#: ../../../components/options_resolver.rst:75
msgid ""
"Now all four options are guaranteed to be set, but you could still make "
"an error like the following when using the ``Mailer`` class::"
msgstr ""

#: ../../../components/options_resolver.rst:82
msgid ""
"No error will be shown. In the best case, the bug will appear during "
"testing, but the developer will spend time looking for the problem. In "
"the worst case, the bug might not appear until it's deployed to the live "
"system."
msgstr ""

#: ../../../components/options_resolver.rst:86
msgid ""
"Fortunately, the "
":class:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver` class"
" helps you to fix this problem::"
msgstr ""

#: ../../../components/options_resolver.rst:109
msgid ""
"Like before, all options will be guaranteed to be set. Additionally, an "
":class:`Symfony\\\\Component\\\\OptionsResolver\\\\Exception\\\\UndefinedOptionsException`"
" is thrown if an unknown option is passed::"
msgstr ""

#: ../../../components/options_resolver.rst:120
msgid ""
"The rest of your code can access the values of the options without "
"boilerplate code::"
msgstr ""

#: ../../../components/options_resolver.rst:139
msgid ""
"It's a good practice to split the option configuration into a separate "
"method::"
msgstr ""

#: ../../../components/options_resolver.rst:166
msgid ""
"First, your code becomes easier to read, especially if the constructor "
"does more than processing options. Second, sub-classes may now override "
"the ``configureOptions()`` method to adjust the configuration of the "
"options::"
msgstr ""

#: ../../../components/options_resolver.rst:185
msgid "Required Options"
msgstr ""

#: ../../../components/options_resolver.rst:187
msgid ""
"If an option must be set by the caller, pass that option to "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::setRequired`."
" For example, to make the ``host`` option required, you can do::"
msgstr ""

#: ../../../components/options_resolver.rst:203
msgid ""
"If you omit a required option, a "
":class:`Symfony\\\\Component\\\\OptionsResolver\\\\Exception\\\\MissingOptionsException`"
" will be thrown::"
msgstr ""

#: ../../../components/options_resolver.rst:211
msgid ""
"The "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::setRequired`"
" method accepts a single name or an array of option names if you have "
"more than one required option::"
msgstr ""

#: ../../../components/options_resolver.rst:227
msgid ""
"Use "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::isRequired`"
" to find out if an option is required. You can use "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::getRequiredOptions`"
" to retrieve the names of all required options::"
msgstr ""

#: ../../../components/options_resolver.rst:247
msgid ""
"If you want to check whether a required option is still missing from the "
"default options, you can use "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::isMissing`."
" The difference between this and "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::isRequired`"
" is that this method will return false if a required option has already "
"been set::"
msgstr ""

#: ../../../components/options_resolver.rst:288
msgid ""
"The "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::getMissingOptions`"
" method lets you access the names of all missing options."
msgstr ""

#: ../../../components/options_resolver.rst:292
msgid "Type Validation"
msgstr ""

#: ../../../components/options_resolver.rst:294
msgid ""
"You can run additional checks on the options to make sure they were "
"passed correctly. To validate the types of the options, call "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::setAllowedTypes`::"
msgstr ""

#: ../../../components/options_resolver.rst:319
msgid ""
"You can pass any type for which an ``is_<type>()`` function is defined in"
" PHP. You may also pass fully qualified class or interface names (which "
"is checked using ``instanceof``). Additionally, you can validate all "
"items in an array recursively by suffixing the type with ``[]``."
msgstr ""

#: ../../../components/options_resolver.rst:324
msgid ""
"If you pass an invalid option now, an "
":class:`Symfony\\\\Component\\\\OptionsResolver\\\\Exception\\\\InvalidOptionsException`"
" is thrown::"
msgstr ""

#: ../../../components/options_resolver.rst:335
msgid ""
"In sub-classes, you can use "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::addAllowedTypes`"
" to add additional allowed types without erasing the ones already set."
msgstr ""

#: ../../../components/options_resolver.rst:339
msgid "Value Validation"
msgstr ""

#: ../../../components/options_resolver.rst:341
msgid ""
"Some options can only take one of a fixed list of predefined values. For "
"example, suppose the ``Mailer`` class has a ``transport`` option which "
"can be one of ``sendmail``, ``mail`` and ``smtp``. Use the method "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::setAllowedValues`"
" to verify that the passed option contains one of these values::"
msgstr ""

#: ../../../components/options_resolver.rst:360
msgid ""
"If you pass an invalid transport, an "
":class:`Symfony\\\\Component\\\\OptionsResolver\\\\Exception\\\\InvalidOptionsException`"
" is thrown::"
msgstr ""

#: ../../../components/options_resolver.rst:371
msgid ""
"For options with more complicated validation schemes, pass a closure "
"which returns ``true`` for acceptable values and ``false`` for invalid "
"values::"
msgstr ""

#: ../../../components/options_resolver.rst:379
msgid ""
"In sub-classes, you can use "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::addAllowedValues`"
" to add additional allowed values without erasing the ones already set."
msgstr ""

#: ../../../components/options_resolver.rst:383
msgid "Option Normalization"
msgstr ""

#: ../../../components/options_resolver.rst:385
msgid ""
"Sometimes, option values need to be normalized before you can use them. "
"For instance, assume that the ``host`` should always start with "
"``http://``. To do that, you can write normalizers. Normalizers are "
"executed after validating an option. You can configure a normalizer by "
"calling "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::setNormalizer`::"
msgstr ""

#: ../../../components/options_resolver.rst:412
msgid ""
"The normalizer receives the actual ``$value`` and returns the normalized "
"form. You see that the closure also takes an ``$options`` parameter. This"
" is useful if you need to use other options during normalization::"
msgstr ""

#: ../../../components/options_resolver.rst:437
msgid ""
"To normalize a new allowed value in sub-classes that are being normalized"
" in parent classes use "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::addNormalizer`."
" This way, the ``$value`` argument will receive the previously normalized"
" value, otherwise you can prepend the new normalizer by passing ``true`` "
"as third argument."
msgstr ""

#: ../../../components/options_resolver.rst:444
msgid "Default Values that Depend on another Option"
msgstr ""

#: ../../../components/options_resolver.rst:446
msgid ""
"Suppose you want to set the default value of the ``port`` option based on"
" the encryption chosen by the user of the ``Mailer`` class. More "
"precisely, you want to set the port to ``465`` if SSL is used and to "
"``25`` otherwise."
msgstr ""

#: ../../../components/options_resolver.rst:450
msgid ""
"You can implement this feature by passing a closure as the default value "
"of the ``port`` option. The closure receives the options as argument. "
"Based on these options, you can return the desired default value::"
msgstr ""

#: ../../../components/options_resolver.rst:477
msgid ""
"The argument of the callable must be type hinted as ``Options``. "
"Otherwise, the callable itself is considered as the default value of the "
"option."
msgstr ""

#: ../../../components/options_resolver.rst:482
msgid ""
"The closure is only executed if the ``port`` option isn't set by the user"
" or overwritten in a sub-class."
msgstr ""

#: ../../../components/options_resolver.rst:485
msgid ""
"A previously set default value can be accessed by adding a second "
"argument to the closure::"
msgstr ""

#: ../../../components/options_resolver.rst:519
msgid ""
"As seen in the example, this feature is mostly useful if you want to "
"reuse the default values set in parent classes in sub-classes."
msgstr ""

#: ../../../components/options_resolver.rst:523
msgid "Options without Default Values"
msgstr ""

#: ../../../components/options_resolver.rst:525
msgid ""
"In some cases, it is useful to define an option without setting a default"
" value. This is useful if you need to know whether or not the user "
"*actually* set an option or not. For example, if you set the default "
"value for an option, it's not possible to know whether the user passed "
"this value or if it comes from the default::"
msgstr ""

#: ../../../components/options_resolver.rst:552
msgid ""
"You can use "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::setDefined`"
" to define an option without setting a default value. Then the option "
"will only be included in the resolved options if it was actually passed "
"to "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::resolve`::"
msgstr ""

#: ../../../components/options_resolver.rst:589
msgid ""
"You can also pass an array of option names if you want to define multiple"
" options in one go::"
msgstr ""

#: ../../../components/options_resolver.rst:603
msgid ""
"The methods "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::isDefined`"
" and "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::getDefinedOptions`"
" let you find out which options are defined::"
msgstr ""

#: ../../../components/options_resolver.rst:629
msgid "Nested Options"
msgstr ""

#: ../../../components/options_resolver.rst:631
msgid ""
"Suppose you have an option named ``spool`` which has two sub-options "
"``type`` and ``path``. Instead of defining it as a simple array of "
"values, you can pass a closure as the default value of the ``spool`` "
"option with a "
":class:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver` "
"argument. Based on this instance, you can define the options under "
"``spool`` and its desired default value::"
msgstr ""

#: ../../../components/options_resolver.rst:668
msgid ""
"Nested options also support required options, validation (type, value) "
"and normalization of their values. If the default value of a nested "
"option depends on another option defined in the parent level, add a "
"second ``Options`` argument to the closure to access to them::"
msgstr ""

#: ../../../components/options_resolver.rst:691
msgid ""
"The arguments of the closure must be type hinted as ``OptionsResolver`` "
"and ``Options`` respectively. Otherwise, the closure itself is considered"
" as the default value of the option."
msgstr ""

#: ../../../components/options_resolver.rst:695
msgid ""
"In same way, parent options can access to the nested options as normal "
"arrays::"
msgstr ""

#: ../../../components/options_resolver.rst:717
msgid ""
"The fact that an option is defined as nested means that you must pass an "
"array of values to resolve it at runtime."
msgstr ""

#: ../../../components/options_resolver.rst:721
msgid "Deprecating the Option"
msgstr ""

#: ../../../components/options_resolver.rst:723
msgid ""
"Once an option is outdated or you decided not to maintain it anymore, you"
" can deprecate it using the "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::setDeprecated`"
" method::"
msgstr ""

#: ../../../components/options_resolver.rst:739
msgid ""
"The deprecation message will be triggered only if the option is being "
"used somewhere, either its value is provided by the user or the option is"
" evaluated within closures of lazy options and normalizers."
msgstr ""

#: ../../../components/options_resolver.rst:745
msgid ""
"When using an option deprecated by you in your own library, you can pass "
"``false`` as the second argument of the "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\Options::offsetGet` "
"method to not trigger the deprecation warning."
msgstr ""

#: ../../../components/options_resolver.rst:750
msgid ""
"Instead of passing the message, you may also pass a closure which returns"
" a string (the deprecation message) or an empty string to ignore the "
"deprecation. This closure is useful to only deprecate some of the allowed"
" types or values of the option::"
msgstr ""

#: ../../../components/options_resolver.rst:775
msgid ""
"Deprecation based on the value is triggered only when the option is "
"provided by the user."
msgstr ""

#: ../../../components/options_resolver.rst:778
msgid ""
"This closure receives as argument the value of the option after "
"validating it and before normalizing it when the option is being "
"resolved."
msgstr ""

#: ../../../components/options_resolver.rst:782
msgid "Chaining Option Configurations"
msgstr ""

#: ../../../components/options_resolver.rst:784
msgid ""
"In many cases you may need to define multiple configurations for each "
"option. For example, suppose the ``InvoiceMailer`` class has an ``host`` "
"option that is required and a ``transport`` option which can be one of "
"``sendmail``, ``mail`` and ``smtp``. You can improve the readability of "
"the code avoiding to duplicate option name for each configuration using "
"the "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::define`"
" method::"
msgstr ""

#: ../../../components/options_resolver.rst:811
msgid ""
"The "
":method:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver::define`"
" method was introduced in Symfony 5.1."
msgstr ""

#: ../../../components/options_resolver.rst:815
msgid "Performance Tweaks"
msgstr ""

#: ../../../components/options_resolver.rst:817
msgid ""
"With the current implementation, the ``configureOptions()`` method will "
"be called for every single instance of the ``Mailer`` class. Depending on"
" the amount of option configuration and the number of created instances, "
"this may add noticeable overhead to your application. If that overhead "
"becomes a problem, you can change your code to do the configuration only "
"once per class::"
msgstr ""

#: ../../../components/options_resolver.rst:850
msgid ""
"Now the "
":class:`Symfony\\\\Component\\\\OptionsResolver\\\\OptionsResolver` "
"instance will be created once per class and reused from that on. Be aware"
" that this may lead to memory leaks in long-running applications, if the "
"default options contain references to objects or object graphs. If that's"
" the case for you, implement a method ``clearOptionsConfig()`` and call "
"it periodically::"
msgstr ""

#: ../../../components/options_resolver.rst:869
msgid ""
"That's it! You now have all the tools and knowledge needed to process "
"options in your code."
msgstr ""

