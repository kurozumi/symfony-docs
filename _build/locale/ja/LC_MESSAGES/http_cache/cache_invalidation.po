# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Symfony Framework
# Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Symfony Framework Documentation \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-08 14:21+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../../../http_cache/cache_invalidation.rst:7
msgid "Cache Invalidation"
msgstr ""

#: ../../../http_cache/cache_invalidation.rst:9
msgid ""
"\"There are only two hard things in Computer Science: cache invalidation "
"and naming things.\" -- Phil Karlton"
msgstr ""

#: ../../../http_cache/cache_invalidation.rst:12
msgid ""
"Once a URL is cached by a gateway cache, the cache will not ask the "
"application for that content anymore. This allows the cache to provide "
"fast responses and reduces the load on your application. However, you "
"risk delivering outdated content. A way out of this dilemma is to use "
"long cache lifetimes, but to actively notify the gateway cache when "
"content changes. Reverse proxies usually provide a channel to receive "
"such notifications, typically through special HTTP requests."
msgstr ""

#: ../../../http_cache/cache_invalidation.rst:22
msgid ""
"While cache invalidation is powerful, avoid it when possible. If you fail"
" to invalidate something, outdated caches will be served for a "
"potentially long time. Instead, use short cache lifetimes or use the "
"validation model, and adjust your controllers to perform efficient "
"validation checks as explained in :ref:`optimizing-cache-validation`."
msgstr ""

#: ../../../http_cache/cache_invalidation.rst:28
msgid ""
"Furthermore, since invalidation is a topic specific to each type of "
"reverse proxy, using this concept will tie you to a specific reverse "
"proxy or need additional efforts to support different proxies."
msgstr ""

#: ../../../http_cache/cache_invalidation.rst:32
msgid ""
"Sometimes, however, you need that extra performance you can get when "
"explicitly invalidating. For invalidation, your application needs to "
"detect when content changes and tell the cache to remove the URLs which "
"contain that data from its cache."
msgstr ""

#: ../../../http_cache/cache_invalidation.rst:39
msgid ""
"If you want to use cache invalidation, have a look at the "
"`FOSHttpCacheBundle`_. This bundle provides services to help with various"
" cache invalidation concepts and also documents the configuration for a "
"couple of common caching proxies."
msgstr ""

#: ../../../http_cache/cache_invalidation.rst:44
msgid ""
"If one content corresponds to one URL, the ``PURGE`` model works well. "
"You send a request to the cache proxy with the HTTP method ``PURGE`` "
"(using the word \"PURGE\" is a convention, technically this can be any "
"string) instead of ``GET`` and make the cache proxy detect this and "
"remove the data from the cache instead of going to the application to get"
" a response."
msgstr ""

#: ../../../http_cache/cache_invalidation.rst:50
msgid ""
"Here is how you can configure the Symfony reverse proxy (See "
":doc:`/http_cache`) to support the ``PURGE`` HTTP method::"
msgstr ""

#: ../../../http_cache/cache_invalidation.rst:89
msgid ""
"You must protect the ``PURGE`` HTTP method somehow to avoid random people"
" purging your cached data."
msgstr ""

#: ../../../http_cache/cache_invalidation.rst:92
msgid ""
"**Purge** instructs the cache to drop a resource in *all its variants* "
"(according to the ``Vary`` header, see above). An alternative to purging "
"is **refreshing** a content. Refreshing means that the caching proxy is "
"instructed to discard its local cache and fetch the content again. This "
"way, the new content is already available in the cache. The drawback of "
"refreshing is that variants are not invalidated."
msgstr ""

#: ../../../http_cache/cache_invalidation.rst:99
msgid ""
"In many applications, the same content bit is used on various pages with "
"different URLs. More flexible concepts exist for those cases:"
msgstr ""

#: ../../../http_cache/cache_invalidation.rst:102
msgid ""
"**Banning** invalidates responses matching regular expressions on the URL"
" or other criteria;"
msgstr ""

#: ../../../http_cache/cache_invalidation.rst:104
msgid ""
"**Cache tagging** lets you add a tag for each content used in a response "
"so that you can invalidate all URLs containing a certain content."
msgstr ""

