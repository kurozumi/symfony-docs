# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Symfony Framework
# Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Symfony Framework Documentation \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-08 14:21+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../../../security/access_control.rst:4
msgid "How Does the Security access_control Work?"
msgstr ""

#: ../../../security/access_control.rst:6
msgid ""
"For each incoming request, Symfony checks each ``access_control`` entry "
"to find *one* that matches the current request. As soon as it finds a "
"matching ``access_control`` entry, it stops - only the **first** matching"
" ``access_control`` is used to enforce access."
msgstr ""

#: ../../../security/access_control.rst:11
msgid ""
"Each ``access_control`` has several options that configure two different "
"things:"
msgstr ""

#: ../../../security/access_control.rst:14
msgid ""
":ref:`should the incoming request match this access control entry "
"<security-access-control-matching-options>`"
msgstr ""

#: ../../../security/access_control.rst:15
msgid ""
":ref:`once it matches, should some sort of access restriction be enforced"
" <security-access-control-enforcement-options>`:"
msgstr ""

#: ../../../security/access_control.rst:20
msgid "1. Matching Options"
msgstr ""

#: ../../../security/access_control.rst:22
msgid ""
"Symfony creates an instance of "
":class:`Symfony\\\\Component\\\\HttpFoundation\\\\RequestMatcher` for "
"each ``access_control`` entry, which determines whether or not a given "
"access control should be used on this request. The following "
"``access_control`` options are used for matching:"
msgstr ""

#: ../../../security/access_control.rst:27
msgid "``path``: a regular expression (without delimiters)"
msgstr ""

#: ../../../security/access_control.rst:28
msgid "``ip`` or ``ips``: netmasks are also supported"
msgstr ""

#: ../../../security/access_control.rst:29
msgid "``port``: an integer"
msgstr ""

#: ../../../security/access_control.rst:30
msgid "``host``: a regular expression"
msgstr ""

#: ../../../security/access_control.rst:31
msgid "``methods``: one or many methods"
msgstr ""

#: ../../../security/access_control.rst:33
msgid "Take the following ``access_control`` entries as an example:"
msgstr ""

#: ../../../security/access_control.rst:99
msgid ""
"For each incoming request, Symfony will decide which ``access_control`` "
"to use based on the URI, the client's IP address, the incoming host name,"
" and the request method. Remember, the first rule that matches is used, "
"and if ``ip``, ``port``, ``host`` or ``method`` are not specified for an "
"entry, that ``access_control`` will match any ``ip``, ``port``, ``host`` "
"or ``method``:"
msgstr ""

#: ../../../security/access_control.rst:106
msgid "URI"
msgstr ""

#: ../../../security/access_control.rst:106
msgid "IP"
msgstr ""

#: ../../../security/access_control.rst:106
msgid "PORT"
msgstr ""

#: ../../../security/access_control.rst:106
msgid "HOST"
msgstr ""

#: ../../../security/access_control.rst:106
msgid "METHOD"
msgstr ""

#: ../../../security/access_control.rst:106
msgid "``access_control``"
msgstr ""

#: ../../../security/access_control.rst:106
msgid "Why?"
msgstr ""

#: ../../../security/access_control.rst:108
#: ../../../security/access_control.rst:110
#: ../../../security/access_control.rst:114
#: ../../../security/access_control.rst:116
#: ../../../security/access_control.rst:119
#: ../../../security/access_control.rst:123
msgid "``/admin/user``"
msgstr ""

#: ../../../security/access_control.rst:108
#: ../../../security/access_control.rst:110
#: ../../../security/access_control.rst:114
#: ../../../security/access_control.rst:126
msgid "127.0.0.1"
msgstr ""

#: ../../../security/access_control.rst:108
#: ../../../security/access_control.rst:110
#: ../../../security/access_control.rst:116
#: ../../../security/access_control.rst:119
#: ../../../security/access_control.rst:123
#: ../../../security/access_control.rst:126
msgid "80"
msgstr ""

#: ../../../security/access_control.rst:108
#: ../../../security/access_control.rst:123
msgid "example.com"
msgstr ""

#: ../../../security/access_control.rst:108
#: ../../../security/access_control.rst:110
#: ../../../security/access_control.rst:114
#: ../../../security/access_control.rst:116
msgid "GET"
msgstr ""

#: ../../../security/access_control.rst:108
#: ../../../security/access_control.rst:110
msgid "rule #1 (``ROLE_USER_IP``)"
msgstr ""

#: ../../../security/access_control.rst:108
msgid "The URI matches ``path`` and the IP matches ``ip``."
msgstr ""

#: ../../../security/access_control.rst:110
#: ../../../security/access_control.rst:114
#: ../../../security/access_control.rst:116
#: ../../../security/access_control.rst:119
#: ../../../security/access_control.rst:126
msgid "symfony.com"
msgstr ""

#: ../../../security/access_control.rst:110
msgid ""
"The ``path`` and ``ip`` still match. This would also match the "
"``ROLE_USER_HOST`` entry, but *only* the **first** ``access_control`` "
"match is used."
msgstr ""

#: ../../../security/access_control.rst:114
msgid "8080"
msgstr ""

#: ../../../security/access_control.rst:114
msgid "rule #2 (``ROLE_USER_PORT``)"
msgstr ""

#: ../../../security/access_control.rst:114
msgid "The ``path``, ``ip`` and ``port`` match."
msgstr ""

#: ../../../security/access_control.rst:116
#: ../../../security/access_control.rst:119
#: ../../../security/access_control.rst:123
msgid "168.0.0.1"
msgstr ""

#: ../../../security/access_control.rst:116
#: ../../../security/access_control.rst:119
msgid "rule #3 (``ROLE_USER_HOST``)"
msgstr ""

#: ../../../security/access_control.rst:116
msgid ""
"The ``ip`` doesn't match the first rule, so the second rule (which "
"matches) is used."
msgstr ""

#: ../../../security/access_control.rst:119
#: ../../../security/access_control.rst:123
#: ../../../security/access_control.rst:126
msgid "POST"
msgstr ""

#: ../../../security/access_control.rst:119
msgid ""
"The second rule still matches. This would also match the third rule "
"(``ROLE_USER_METHOD``), but only the **first** matched ``access_control``"
" is used."
msgstr ""

#: ../../../security/access_control.rst:123
msgid "rule #4 (``ROLE_USER_METHOD``)"
msgstr ""

#: ../../../security/access_control.rst:123
msgid ""
"The ``ip`` and ``host`` don't match the first two entries, but the third "
"- ``ROLE_USER_METHOD`` - matches and is used."
msgstr ""

#: ../../../security/access_control.rst:126
msgid "``/foo``"
msgstr ""

#: ../../../security/access_control.rst:126
msgid "matches no entries"
msgstr ""

#: ../../../security/access_control.rst:126
msgid ""
"This doesn't match any ``access_control`` rules, since its URI doesn't "
"match any of the ``path`` values."
msgstr ""

#: ../../../security/access_control.rst:132
msgid ""
"Matching the URI is done without ``$_GET`` parameters. :ref:`Deny access "
"in PHP code <security-securing-controller>` if you want to disallow "
"access based on ``$_GET`` parameter values."
msgstr ""

#: ../../../security/access_control.rst:139
msgid "2. Access Enforcement"
msgstr ""

#: ../../../security/access_control.rst:141
msgid ""
"Once Symfony has decided which ``access_control`` entry matches (if any),"
" it then *enforces* access restrictions based on the ``roles``, "
"``allow_if`` and ``requires_channel`` options:"
msgstr ""

#: ../../../security/access_control.rst:145
msgid ""
"``roles`` If the user does not have the given role, then access is denied"
" (internally, an "
":class:`Symfony\\\\Component\\\\Security\\\\Core\\\\Exception\\\\AccessDeniedException`"
" is thrown). If this value is an array of multiple roles, the user must "
"have at least one of them."
msgstr ""

#: ../../../security/access_control.rst:150
msgid "``allow_if`` If the expression returns false, then access is denied;"
msgstr ""

#: ../../../security/access_control.rst:152
msgid ""
"``requires_channel`` If the incoming request's channel (e.g. ``http``) "
"does not match this value (e.g. ``https``), the user will be redirected "
"(e.g. redirected from ``http`` to ``https``, or vice versa)."
msgstr ""

#: ../../../security/access_control.rst:158
msgid ""
"Behind the scenes, the array value of ``roles`` is passed as the "
"``$attributes`` argument to each voter in the application with the "
":class:`Symfony\\\\Component\\\\HttpFoundation\\\\Request` as "
"``$subject``. You can learn how to use your custom attributes by reading "
":ref:`security/custom-voter`."
msgstr ""

#: ../../../security/access_control.rst:166
msgid ""
"If you define both ``roles`` and ``allow_if``, and your Access Decision "
"Strategy is the default one (``affirmative``), then the user will be "
"granted access if there's at least one valid condition. If this behavior "
"doesn't fit your needs, :ref:`change the Access Decision Strategy "
"<security-voters-change-strategy>`."
msgstr ""

#: ../../../security/access_control.rst:173
msgid ""
"If access is denied, the system will try to authenticate the user if not "
"already (e.g. redirect the user to the login page). If the user is "
"already logged in, the 403 \"access denied\" error page will be shown. "
"See :doc:`/controller/error_pages` for more information."
msgstr ""

#: ../../../security/access_control.rst:179
msgid "Matching access_control By IP"
msgstr ""

#: ../../../security/access_control.rst:181
msgid ""
"Certain situations may arise when you need to have an ``access_control`` "
"entry that *only* matches requests coming from some IP address or range. "
"For example, this *could* be used to deny access to a URL pattern to all "
"requests *except* those from a trusted, internal server."
msgstr ""

#: ../../../security/access_control.rst:188
msgid ""
"As you'll read in the explanation below the example, the ``ips`` option "
"does not restrict to a specific IP address. Instead, using the ``ips`` "
"key means that the ``access_control`` entry will only match this IP "
"address, and users accessing it from a different IP address will continue"
" down the ``access_control`` list."
msgstr ""

#: ../../../security/access_control.rst:194
msgid ""
"Here is an example of how you configure some example ``/internal*`` URL "
"pattern so that it is only accessible by requests from the local server "
"itself:"
msgstr ""

#: ../../../security/access_control.rst:254
msgid ""
"Here is how it works when the path is ``/internal/something`` coming from"
" the external IP address ``10.0.0.1``:"
msgstr ""

#: ../../../security/access_control.rst:257
msgid ""
"The first access control rule is ignored as the ``path`` matches but the "
"IP address does not match either of the IPs listed;"
msgstr ""

#: ../../../security/access_control.rst:260
msgid ""
"The second access control rule is enabled (the only restriction being the"
" ``path``) and so it matches. If you make sure that no users ever have "
"``ROLE_NO_ACCESS``, then access is denied (``ROLE_NO_ACCESS`` can be "
"anything that does not match an existing role, it just serves as a trick "
"to always deny access)."
msgstr ""

#: ../../../security/access_control.rst:266
msgid ""
"But if the same request comes from ``127.0.0.1`` or ``::1`` (the IPv6 "
"loopback address):"
msgstr ""

#: ../../../security/access_control.rst:269
msgid ""
"Now, the first access control rule is enabled as both the ``path`` and "
"the ``ip`` match: access is allowed as the user always has the "
"``IS_AUTHENTICATED_ANONYMOUSLY`` role."
msgstr ""

#: ../../../security/access_control.rst:273
msgid "The second access rule is not examined as the first rule matched."
msgstr ""

#: ../../../security/access_control.rst:278
msgid "Securing by an Expression"
msgstr ""

#: ../../../security/access_control.rst:280
msgid ""
"Once an ``access_control`` entry is matched, you can deny access via the "
"``roles`` key or use more complex logic with an expression in the "
"``allow_if`` key:"
msgstr ""

#: ../../../security/access_control.rst:337
msgid ""
"In this case, when the user tries to access any URL starting with "
"``/_internal/secure``, they will only be granted access if the IP address"
" is ``127.0.0.1`` or a secure header, or if the user has the "
"``ROLE_ADMIN`` role."
msgstr ""

#: ../../../security/access_control.rst:343
msgid ""
"Internally ``allow_if`` triggers the built-in "
":class:`Symfony\\\\Component\\\\Security\\\\Core\\\\Authorization\\\\Voter\\\\ExpressionVoter`"
" as like it was part of the attributes defined in the ``roles`` option."
msgstr ""

#: ../../../security/access_control.rst:347
msgid ""
"Inside the expression, you have access to a number of different variables"
" and functions including ``request``, which is the Symfony "
":class:`Symfony\\\\Component\\\\HttpFoundation\\\\Request` object (see "
":ref:`component-http-foundation-request`)."
msgstr ""

#: ../../../security/access_control.rst:352
msgid ""
"For a list of the other functions and variables, see :ref:`functions and "
"variables <security-expression-variables>`."
msgstr ""

#: ../../../security/access_control.rst:357
msgid ""
"The ``allow_if`` expressions can also contain custom functions registered"
" with :ref:`expression providers <components-expression-language-"
"provider>`."
msgstr ""

#: ../../../security/access_control.rst:361
msgid "Restrict to a port"
msgstr ""

#: ../../../security/access_control.rst:363
msgid ""
"Add the ``port`` option to any ``access_control`` entries to require "
"users to access those URLs via a specific port. This could be useful for "
"example for ``localhost:8080``."
msgstr ""

#: ../../../security/access_control.rst:413
msgid "Forcing a Channel (http, https)"
msgstr ""

#: ../../../security/access_control.rst:415
msgid ""
"You can also require a user to access a URL via SSL; use the "
"``requires_channel`` argument in any ``access_control`` entries. If this "
"``access_control`` is matched and the request is using the ``http`` "
"channel, the user will be redirected to ``https``:"
msgstr ""

